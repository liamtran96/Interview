---
sidebar_position: 4
difficulty: Easy
tags: [binary-search, math, microsoft, google, amazon]
leetcode_url: https://leetcode.com/problems/valid-perfect-square/
companies: [Microsoft, Google, Amazon, Facebook, LinkedIn]
pattern: "Binary Search"
---

import AlgorithmProblem from '@site/src/components/AlgorithmProblem';

# Valid Perfect Square

<AlgorithmProblem
  title="Valid Perfect Square"
  difficulty="Easy"
  description={`
<p>Given a positive integer <code>num</code>, return <code>true</code> if <code>num</code> is a perfect square or <code>false</code> otherwise.</p>
<p>A <strong>perfect square</strong> is an integer that is the square of an integer. In other words, it is the product of some integer with itself.</p>
<p>You must not use any built-in library function, such as <code>sqrt</code>.</p>
<h4>Constraints:</h4>
<ul>
  <li>1 &lt;= num &lt;= 2<sup>31</sup> - 1</li>
</ul>
`}
  examples={[
    {
      input: 'num = 16',
      output: 'true',
      explanation: 'We return true because 4 * 4 = 16 and 4 is an integer.'
    },
    {
      input: 'num = 14',
      output: 'false',
      explanation: 'We return false because 3.742 * 3.742 = 14 and 3.742 is not an integer.'
    },
    {
      input: 'num = 1',
      output: 'true',
      explanation: 'We return true because 1 * 1 = 1 and 1 is an integer.'
    }
  ]}
  starterCode={`function isPerfectSquare(num) {
  // Write your code here

}`}
  solution={`function isPerfectSquare(num) {
  // Binary search: O(log n) time, O(1) space
  if (num === 1) return true;

  let left = 1;
  let right = Math.floor(num / 2); // sqrt(n) is at most n/2 for n >= 2

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);
    const square = mid * mid;

    if (square === num) {
      return true; // Found perfect square
    } else if (square < num) {
      left = mid + 1; // Square too small, search right
    } else {
      right = mid - 1; // Square too large, search left
    }
  }

  return false; // No perfect square found
}`}
  testCases={[
    {
      input: [16],
      expected: true,
      description: 'Perfect square: 16 = 4 * 4'
    },
    {
      input: [14],
      expected: false,
      description: 'Not a perfect square: 14'
    },
    {
      input: [1],
      expected: true,
      description: 'Edge case: 1 = 1 * 1'
    },
    {
      input: [2147395600],
      expected: true,
      description: 'Large perfect square: 2147395600 = 46340 * 46340'
    },
    {
      input: [2147483647],
      expected: false,
      description: 'Max integer, not perfect square'
    },
    {
      input: [100],
      expected: true,
      description: 'Common perfect square: 100 = 10 * 10'
    }
  ]}
  functionName="isPerfectSquare"
/>

## Solution Explanation

### Approach 1: Linear Search (Too Slow)

**Time Complexity:** O(√n)
**Space Complexity:** O(1)

Check each number from 1 to √n:

```javascript
function isPerfectSquare(num) {
  for (let i = 1; i * i <= num; i++) {
    if (i * i === num) {
      return true;
    }
  }
  return false;
}
```

**Why not use this?**
- For num = 2³¹ - 1, needs ~46,340 iterations
- Still O(√n) which is slower than O(log n)
- Not optimal for large numbers

### Approach 2: Binary Search (Optimal) ✅

**Time Complexity:** O(log n)
**Space Complexity:** O(1)

Search for the square root in the range [1, num/2]:

```javascript
function isPerfectSquare(num) {
  if (num === 1) return true;

  let left = 1;
  let right = Math.floor(num / 2); // Optimization: sqrt(n) <= n/2 for n >= 2

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);
    const square = mid * mid;

    if (square === num) {
      return true; // Found it!
    } else if (square < num) {
      left = mid + 1; // Need larger square root
    } else {
      right = mid - 1; // Need smaller square root
    }
  }

  return false;
}
```

**How Binary Search Works:**

```
num = 16

Step 1: left=1, right=8, mid=4
  4 * 4 = 16 = 16
  Found! Return true ✅

num = 14

Step 1: left=1, right=7, mid=4
  4 * 4 = 16 > 14
  Search left: right=3

Step 2: left=1, right=3, mid=2
  2 * 2 = 4 < 14
  Search right: left=3

Step 3: left=3, right=3, mid=3
  3 * 3 = 9 < 14
  Search right: left=4

Step 4: left=4, right=3
  Loop ends (left > right)
  Return false ✅
```

**Search Space Optimization:**

```
For num >= 2, the square root is at most num/2:
  √4 = 2 = 4/2
  √16 = 4 < 16/2 = 8
  √100 = 10 < 100/2 = 50

So we can set right = num/2 instead of right = num
This makes the search space smaller!
```

### Approach 3: Newton's Method (Alternative)

**Time Complexity:** O(log n)
**Space Complexity:** O(1)

Use Newton's iterative method to find square root:

```javascript
function isPerfectSquare(num) {
  if (num === 1) return true;

  let x = num;

  while (x * x > num) {
    x = Math.floor((x + Math.floor(num / x)) / 2);
  }

  return x * x === num;
}
```

**Newton's Method Formula:**
```
x(n+1) = (x(n) + num/x(n)) / 2

Converges to √num very quickly!
```

**Note:** Binary search is more intuitive and equally efficient.

### Approach 4: Mathematical Pattern (Smart but Not General)

**Time Complexity:** O(√n)
**Space Complexity:** O(1)

Perfect squares follow a pattern: 1 + 3 + 5 + 7 + ... = n²

```javascript
function isPerfectSquare(num) {
  let i = 1;
  while (num > 0) {
    num -= i;
    i += 2;
  }
  return num === 0;
}
```

**Why this works:**
```
1 = 1
4 = 1 + 3
9 = 1 + 3 + 5
16 = 1 + 3 + 5 + 7
```

**Note:** Interesting but still O(√n), not as efficient as binary search!

### Key Insights

1. **Binary search on answer space**: We search for the square root value
2. **Search range optimization**: sqrt(n) ≤ n/2 for n ≥ 2
3. **Overflow prevention**: Use `mid * mid` carefully or check before multiplying
4. **Early exit**: Return immediately when exact match found
5. **Logarithmic efficiency**: O(log n) is much faster than O(√n) for large numbers

## Common Mistakes

❌ **Not handling overflow in mid * mid:**
```javascript
const square = mid * mid; // Can overflow for large mid!
// Should check: if (mid > num / mid) { ... }
```

❌ **Setting wrong search range:**
```javascript
let right = num; // Works but inefficient - should be num/2
```

❌ **Using built-in sqrt function:**
```javascript
return Math.sqrt(num) % 1 === 0; // Violates problem constraints!
```

❌ **Floating point comparison issues:**
```javascript
const sqrt = Math.sqrt(num);
return sqrt === Math.floor(sqrt); // Not allowed and unreliable
```

✅ **Correct implementation with overflow protection:**
```javascript
function isPerfectSquare(num) {
  if (num === 1) return true;

  let left = 1;
  let right = Math.floor(num / 2);

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    // Prevent overflow by checking mid > num/mid before squaring
    if (mid > num / mid) {
      right = mid - 1;
    } else {
      const square = mid * mid;
      if (square === num) {
        return true;
      } else if (square < num) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
  }

  return false;
}
```

## Interview Tips

**When discussing this problem:**
1. Clarify: "We need to check if num is a perfect square without using sqrt()"
2. Recognize: "This is essentially finding if an integer square root exists"
3. Approach: "We can binary search for the square root in range [1, num/2]"
4. Optimize: "For num ≥ 2, sqrt(num) is always ≤ num/2"
5. Edge case: "Handle num = 1 separately"

**Key talking points:**
- "Binary search is perfect because we're searching for a value (the square root)"
- "We can check mid * mid against num to decide which way to search"
- "This gives us O(log n) time, much better than O(√n) linear approach"
- "Need to be careful about integer overflow for large numbers"

**Why binary search is better than linear:**

```
For num = 2,147,483,647 (max int):
- Linear: ~46,340 iterations
- Binary search: ~15 iterations

Binary search is ~3,000x faster!
```

**Follow-up questions you might get:**
- **What about using Math.sqrt()?** Problem forbids built-in functions
- **How to handle overflow?** Check `mid > num/mid` before computing `mid * mid`
- **Can you find the integer square root (floor)?** Yes, return `right` when loop ends
- **What about negative numbers?** Per constraints, num ≥ 1 (no negatives)
- **Other approaches?** Newton's method works but binary search is more intuitive

**Real-world applications:**
- Integer arithmetic operations (avoiding floating point)
- Cryptography and number theory
- Graphics programming (distance calculations)
- Game development (collision detection)
- Optimization problems requiring integer solutions

**Variants to mention:**
- Finding floor(sqrt(n))
- Finding ceil(sqrt(n))
- Checking if n is a perfect power (cube, 4th power, etc.)
- Finding the k-th root of a number
