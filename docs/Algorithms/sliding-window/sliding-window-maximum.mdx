---
sidebar_position: 8
difficulty: Hard
tags: [arrays, sliding-window, queue, heap, amazon, google]
leetcode_url: https://leetcode.com/problems/sliding-window-maximum/
companies: [Amazon, Google, Facebook, Microsoft, Apple]
pattern: "Sliding Window"
---

import AlgorithmProblem from '@site/src/components/AlgorithmProblem';

# Sliding Window Maximum

<AlgorithmProblem
  title="Sliding Window Maximum"
  difficulty="Hard"
  description={`
<p>You are given an array of integers <code>nums</code>, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p>
<p>Return <em>the max sliding window</em>.</p>
<h4>Constraints:</h4>
<ul>
  <li>1 &lt;= nums.length &lt;= 10<sup>5</sup></li>
  <li>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></li>
  <li>1 &lt;= k &lt;= nums.length</li>
</ul>
`}
  examples={[
    {
      input: 'nums = [1,3,-1,-3,5,3,6,7], k = 3',
      output: '[3,3,5,5,6,7]',
      explanation: 'Window position -> Maximum\n[1  3  -1] -3  5  3  6  7  -> 3\n 1 [3  -1  -3] 5  3  6  7  -> 3\n 1  3 [-1  -3  5] 3  6  7  -> 5\n 1  3  -1 [-3  5  3] 6  7  -> 5\n 1  3  -1  -3 [5  3  6] 7  -> 6\n 1  3  -1  -3  5 [3  6  7] -> 7'
    },
    {
      input: 'nums = [1], k = 1',
      output: '[1]',
      explanation: 'Single element, window size 1'
    },
    {
      input: 'nums = [1,-1], k = 1',
      output: '[1,-1]',
      explanation: 'Window size 1, each element is its own maximum'
    }
  ]}
  starterCode={`function maxSlidingWindow(nums, k) {
  // Write your code here

}`}
  solution={`function maxSlidingWindow(nums, k) {
  // Monotonic deque approach: O(n) time, O(k) space
  const result = [];
  const deque = []; // Stores indices, not values

  for (let i = 0; i < nums.length; i++) {
    // Remove indices outside current window
    while (deque.length > 0 && deque[0] < i - k + 1) {
      deque.shift();
    }

    // Remove smaller elements from back (maintain decreasing order)
    while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) {
      deque.pop();
    }

    // Add current element index
    deque.push(i);

    // Add to result once we have a full window
    if (i >= k - 1) {
      result.push(nums[deque[0]]);
    }
  }

  return result;
}`}
  testCases={[
    {
      input: [[1, 3, -1, -3, 5, 3, 6, 7], 3],
      expected: [3, 3, 5, 5, 6, 7],
      description: 'Standard case: nums=[1,3,-1,-3,5,3,6,7], k=3'
    },
    {
      input: [[1], 1],
      expected: [1],
      description: 'Single element: nums=[1], k=1'
    },
    {
      input: [[1, -1], 1],
      expected: [1, -1],
      description: 'Window size 1: nums=[1,-1], k=1'
    },
    {
      input: [[9, 11], 2],
      expected: [11],
      description: 'Window equals array: nums=[9,11], k=2'
    },
    {
      input: [[7, 2, 4], 2],
      expected: [7, 4],
      description: 'Decreasing then increasing: nums=[7,2,4], k=2'
    },
    {
      input: [[1, 3, 1, 2, 0, 5], 3],
      expected: [3, 3, 2, 5],
      description: 'Complex pattern: nums=[1,3,1,2,0,5], k=3'
    }
  ]}
  functionName="maxSlidingWindow"
/>

## Solution Explanation

### Approach 1: Brute Force (Not Recommended)

**Time Complexity:** O(n × k)
**Space Complexity:** O(n - k + 1) for result

Find maximum in each window:

```javascript
function maxSlidingWindow(nums, k) {
  const result = [];

  for (let i = 0; i <= nums.length - k; i++) {
    let max = nums[i];
    for (let j = i; j < i + k; j++) {
      max = Math.max(max, nums[j]);
    }
    result.push(max);
  }

  return result;
}
```

**Why not use this?**
- O(k) to find max for each window
- O(n) windows total
- Total O(n × k) is too slow for large inputs

### Approach 2: Max Heap (Better, but not optimal)

**Time Complexity:** O(n log k)
**Space Complexity:** O(k)

Use a max heap to track maximum efficiently:

```javascript
function maxSlidingWindow(nums, k) {
  const result = [];
  const maxHeap = new MaxPriorityQueue({ priority: x => x.val });

  // Build initial window
  for (let i = 0; i < k; i++) {
    maxHeap.enqueue({ val: nums[i], idx: i });
  }

  result.push(maxHeap.front().element.val);

  // Slide window
  for (let i = k; i < nums.length; i++) {
    maxHeap.enqueue({ val: nums[i], idx: i });

    // Remove elements outside window
    while (maxHeap.front().element.idx <= i - k) {
      maxHeap.dequeue();
    }

    result.push(maxHeap.front().element.val);
  }

  return result;
}
```

**Better, but:**
- Heap operations are O(log k)
- Still not optimal for sliding window

### Approach 3: Monotonic Deque (Optimal) ✅

**Time Complexity:** O(n)
**Space Complexity:** O(k)

Use a deque to maintain potential maximums in decreasing order:

```javascript
function maxSlidingWindow(nums, k) {
  const result = [];
  const deque = []; // Stores indices, maintains decreasing order of values

  for (let i = 0; i < nums.length; i++) {
    // Step 1: Remove indices that are out of current window
    while (deque.length > 0 && deque[0] < i - k + 1) {
      deque.shift();
    }

    // Step 2: Remove indices whose values are smaller than current
    // (they can never be maximum)
    while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) {
      deque.pop();
    }

    // Step 3: Add current index
    deque.push(i);

    // Step 4: Add maximum to result (once window is full)
    if (i >= k - 1) {
      result.push(nums[deque[0]]);
    }
  }

  return result;
}
```

**How the Monotonic Deque works:**

```
nums = [1,3,-1,-3,5,3,6,7], k = 3
deque stores indices (values shown for clarity)

i=0: nums[0]=1
  deque=[0(1)]

i=1: nums[1]=3
  Remove 0(1) because 1 < 3
  deque=[1(3)]

i=2: nums[2]=-1
  -1 < 3, just add
  deque=[1(3), 2(-1)]
  Window full: max = nums[1] = 3 ✅

i=3: nums[3]=-3
  Remove index 2 because -1 > -3
  deque=[1(3), 3(-3)]
  max = nums[1] = 3 ✅

i=4: nums[4]=5
  Remove index 1 (out of window: 1 < 4-3+1=2)
  Remove 3(-3) because -3 < 5
  deque=[4(5)]
  max = nums[4] = 5 ✅

i=5: nums[5]=3
  5 > 3, just add
  deque=[4(5), 5(3)]
  max = nums[4] = 5 ✅

i=6: nums[6]=6
  Remove index 4 (out of window: 4 < 6-3+1=4)
  Remove 5(3) because 3 < 6
  deque=[6(6)]
  max = nums[6] = 6 ✅

i=7: nums[7]=7
  Remove 6(6) because 6 < 7
  deque=[7(7)]
  max = nums[7] = 7 ✅

Result: [3, 3, 5, 5, 6, 7]
```

### Why Monotonic Deque?

**Key insight:** If we have two elements A and B where:
- A is to the left of B (A enters window earlier)
- A ≤ B (A is smaller or equal)

Then **A can never be the maximum** of any future window that contains B, because:
- B is larger
- B will stay in the window at least as long as A

**Therefore, we can remove A from consideration!**

This maintains a **decreasing sequence** in the deque:
```
deque values: [9, 7, 5, 3] (all could be future maximums)
NOT: [3, 5, 7, 9] (only 9 matters)
```

### Key Insights

1. **Monotonic deque**: Maintains elements in decreasing order
2. **Store indices**: Enables checking if element is in window
3. **Front is maximum**: Deque[0] always has largest value in window
4. **Amortized O(1)**: Each element added once, removed once
5. **Two-ended operations**: Remove from front (expired) and back (smaller)

## Common Mistakes

❌ Storing values instead of indices:
```javascript
// Wrong - can't check if element is in window
deque.push(nums[i]); // Should push index i
```

❌ Not maintaining decreasing order:
```javascript
// Wrong - just adds all elements
deque.push(i); // Should remove smaller elements first
```

❌ Wrong window boundary check:
```javascript
// Wrong - off by one
while (deque[0] <= i - k) // Should be < i - k + 1
```

✅ Correct approach - monotonic deque with indices:
```javascript
const deque = [];

for (let i = 0; i < nums.length; i++) {
  // Remove expired indices
  while (deque.length > 0 && deque[0] < i - k + 1) {
    deque.shift();
  }

  // Remove smaller elements (maintain decreasing order)
  while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) {
    deque.pop();
  }

  // Add current index
  deque.push(i);

  // Collect result
  if (i >= k - 1) {
    result.push(nums[deque[0]]);
  }
}
```

## Interview Tips

**When discussing this problem:**
1. Start with brute force: "Find max in each window - O(n×k)"
2. Mention heap: "We could use max heap - O(n log k)"
3. Optimal solution: "Monotonic deque gives us O(n)"
4. Explain key insight: "If A < B and A is left of B, A can never be max"
5. Walk through deque maintenance: "Remove expired, remove smaller, add current"

**Key talking points:**
- "This is one of the hardest sliding window problems"
- "The trick is using a monotonic decreasing deque"
- "We store indices to check window boundaries"
- "Each element is added once and removed once - amortized O(n)"
- "Front of deque always contains the maximum for current window"

**Complexity analysis:**
- Time: O(n) - each element processed at most twice (add + remove)
- Space: O(k) - deque holds at most k elements

**Follow-up questions you might get:**
- **Why deque instead of stack/queue?** Need to remove from both ends
- **Why store indices not values?** To check if element is in current window
- **What if we want minimum?** Same approach, maintain increasing deque
- **Can we use two stacks?** Yes, but more complex implementation

**Data structure variations:**
- **Monotonic Stack**: For next greater/smaller element problems
- **Monotonic Deque**: For sliding window max/min problems
- **Max Heap**: When we don't need to maintain order, just maximum

**Common patterns:**
1. **Monotonic increasing**: Track minimums, next smaller element
2. **Monotonic decreasing**: Track maximums, next greater element
3. **Sliding window**: Use deque to efficiently track extremes

**Implementation tips:**
1. Always store indices, not values
2. Remove from front: expired elements
3. Remove from back: elements that can't be maximum
4. Front of deque is always the answer
5. Start collecting results when i >= k - 1
