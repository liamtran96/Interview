---
sidebar_position: 6
difficulty: Easy
tags: [trees, diameter, path, amazon, microsoft]
leetcode_url: https://leetcode.com/problems/diameter-of-binary-tree/
companies: [Amazon, Google, Microsoft, Meta, Apple]
pattern: "Trees"
---

import AlgorithmProblem from '@site/src/components/AlgorithmProblem';

# Diameter of Binary Tree

<AlgorithmProblem
  title="Diameter of Binary Tree"
  difficulty="Easy"
  description={`
<p>Given the <code>root</code> of a binary tree, return <strong>the length of the diameter of the tree</strong>.</p>
<p>The diameter of a binary tree is the <strong>length of the longest path between any two nodes</strong> in a tree. This path may or may not pass through the root.</p>
<p><strong>Note:</strong> The length of a path between two nodes is represented by the number of <strong>edges</strong> between them.</p>
<h4>Constraints:</h4>
<ul>
  <li>The number of nodes in the tree is in the range [1, 10<sup>4</sup>]</li>
  <li>-100 ≤ Node.val ≤ 100</li>
</ul>
`}
  examples={[
    {
      input: 'root = [1,2,3,4,5]',
      output: '3'
    },
    {
      input: 'root = [1,2]',
      output: '1'
    },
    {
      input: 'root = [1]',
      output: '0'
    }
  ]}
  starterCode={`class TreeNode {
  constructor(val = 0, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

function diameterOfBinaryTree(root) {
  // TODO: Find the diameter (longest path) of the tree
  return 0;
}`}
  solution={`class TreeNode {
  constructor(val = 0, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

function diameterOfBinaryTree(root) {
  let diameter = 0;

  function dfs(node) {
    if (node === null) return 0;

    // Get height of left and right subtrees
    const leftHeight = dfs(node.left);
    const rightHeight = dfs(node.right);

    // Update global diameter
    // Path through this node = left height + right height
    diameter = Math.max(diameter, leftHeight + rightHeight);

    // Return height of this subtree (add 1 for edge from node)
    return Math.max(leftHeight, rightHeight) + 1;
  }

  dfs(root);
  return diameter;
}`}
  testCases={[
    {
      input: [[[1, 2, 3, 4, 5]]],
      expected: 3,
      description: 'Tree with diameter 3 (path: 4→2→1→3)'
    },
    {
      input: [[[1, 2]]],
      expected: 1,
      description: 'Tree with diameter 1'
    },
    {
      input: [[[1]]],
      expected: 0,
      description: 'Single node (no edges)'
    },
    {
      input: [[[1, 2, 3, 4, 5, 6, 7]]],
      expected: 4,
      description: 'Larger tree with diameter 4'
    },
    {
      input: [[[1, 2, null, 3, null, 4, null]]],
      expected: 3,
      description: 'Skewed tree (linear path)'
    },
    {
      input: [[[1, 2, 3, 4, 5, null, 6, null, null, 7]]],
      expected: 4,
      description: 'Complex tree structure'
    }
  ]}
  functionName="diameterOfBinaryTree"
/>

## Solution Explanation

### Approach 1: DFS with Global Variable (Most Common) ✅

**Time Complexity:** O(n) - visit each node once
**Space Complexity:** O(h) - recursion stack, where h is height

For each node, calculate the longest path through it (left height + right height):

```javascript
function diameterOfBinaryTree(root) {
  let diameter = 0;

  function dfs(node) {
    if (node === null) return 0;

    const leftHeight = dfs(node.left);
    const rightHeight = dfs(node.right);

    // Update diameter: path through this node
    diameter = Math.max(diameter, leftHeight + rightHeight);

    // Return height for parent to use
    return Math.max(leftHeight, rightHeight) + 1;
  }

  dfs(root);
  return diameter;
}
```

**How it works:**

```
Tree:
        1
       / \
      2   3
     / \
    4   5

DFS traversal (post-order):
- Visit node 4: height = 1, diameter = 0
- Visit node 5: height = 1, diameter = 0
- Visit node 2:
  - leftHeight = 1, rightHeight = 1
  - diameter = max(0, 1+1) = 2
  - return 1 + 1 = 2
- Visit node 3: height = 1, diameter = 2
- Visit node 1:
  - leftHeight = 2, rightHeight = 1
  - diameter = max(2, 2+1) = 3 ✅
  - return 2 + 1 = 3

Answer: 3 (path: 4→2→5 or 4→2→1→3)
```

### Approach 2: DFS Returning [height, diameter]

**Time Complexity:** O(n)
**Space Complexity:** O(h)

Return both values to avoid global variable:

```javascript
function diameterOfBinaryTree(root) {
  const [, diameter] = dfs(root);
  return diameter;
}

function dfs(node) {
  if (node === null) return [0, 0];  // [height, diameter]

  const [leftHeight, leftDiam] = dfs(node.left);
  const [rightHeight, rightDiam] = dfs(node.right);

  // Current node's diameter
  const height = Math.max(leftHeight, rightHeight) + 1;
  const diameter = Math.max(
    leftHeight + rightHeight,  // Through current node
    Math.max(leftDiam, rightDiam)  // Through subtrees
  );

  return [height, diameter];
}
```

### Approach 3: BFS + Track Heights (Less Intuitive)

**Time Complexity:** O(n)
**Space Complexity:** O(w) - queue width

Use queue to track nodes with their heights:

```javascript
function diameterOfBinaryTree(root) {
  const queue = [[root, 0]];  // [node, height]
  let maxPath = 0;
  const heights = new Map();

  // Calculate heights first
  while (queue.length > 0) {
    const [node] = queue.shift();
    if (node === null) continue;

    if (!heights.has(node)) {
      queue.push([node.left, 0]);
      queue.push([node.right, 0]);
      const leftH = node.left ? heights.get(node.left) : 0;
      const rightH = node.right ? heights.get(node.right) : 0;
      heights.set(node, Math.max(leftH, rightH) + 1);
    }
  }

  // Find max diameter
  function dfs(node) {
    if (node === null) return 0;
    const leftH = node.left ? heights.get(node.left) : 0;
    const rightH = node.right ? heights.get(node.right) : 0;
    maxPath = Math.max(maxPath, leftH + rightH);
    dfs(node.left);
    dfs(node.right);
    return 0;
  }

  dfs(root);
  return maxPath;
}
```

## Comparison of Approaches

| Approach | Time | Space | Best For | Simplicity |
|----------|------|-------|----------|-----------|
| DFS Global | O(n) | O(h) | **Most elegant** | Easy |
| DFS Tuple | O(n) | O(h) | **No globals** | Medium |
| BFS | O(n) | O(w) | Educational | Hard |

## Common Mistakes

❌ **Confusing diameter with height:**
```javascript
function diameterOfBinaryTree(root) {
  // This returns HEIGHT (longest path from root to leaf)
  // Not DIAMETER (longest path between any two nodes)
  return getHeight(root);
}
```

✅ **Diameter passes through any node, not just root:**
```javascript
function diameterOfBinaryTree(root) {
  let diameter = 0;
  function dfs(node) {
    if (node === null) return 0;
    const left = dfs(node.left);
    const right = dfs(node.right);
    // Check diameter through THIS node (not just root)
    diameter = Math.max(diameter, left + right);
    return Math.max(left, right) + 1;
  }
  dfs(root);
  return diameter;
}
```

---

❌ **Forgetting to check all nodes:**
```javascript
function diameterOfBinaryTree(root) {
  const leftDiam = getDiameter(root.left);
  const rightDiam = getDiameter(root.right);
  // Only checking immediate children's diameters
  return Math.max(leftDiam, rightDiam);
}
```

✅ **Check path through current node too:**
```javascript
function diameterOfBinaryTree(root) {
  let diameter = 0;
  function dfs(node) {
    if (node === null) return 0;
    const left = dfs(node.left);
    const right = dfs(node.right);
    // Must check: left + right (through this node)
    diameter = Math.max(diameter, left + right);
    return Math.max(left, right) + 1;
  }
  dfs(root);
  return diameter;
}
```

---

❌ **Counting nodes instead of edges:**
```javascript
// Edges between nodes, not node count!
// [1,2,3] has 2 edges (1→2 and 1→3), not 3
```

✅ **Remember: edges = nodes - 1 in a path:**
```javascript
// Height = number of edges from node to leaf
// So leftHeight + rightHeight = edges in path through node
```

## Interview Tips

**What to mention:**
1. **Diameter definition:** Longest path between any two nodes
2. **Path location:** Can be anywhere, not just through root
3. **Key insight:** For each node, diameter through it = left height + right height
4. **One-pass solution:** DFS to calculate height and track max diameter

**Follow-up questions:**

**Q: What if we want the actual nodes in the longest path?**
A: Track the path during DFS instead of just counting edges.

**Q: Can there be multiple diameters of the same length?**
A: Yes! Multiple paths could have the same maximum length.

**Q: What about weighted trees?**
A: Same logic, but sum weights instead of counting edges.

## Edge Cases

```javascript
// Single node (no edges)
diameterOfBinaryTree([1]) → 0

// Two nodes
diameterOfBinaryTree([1, 2]) → 1

// Linear tree (all left children)
diameterOfBinaryTree([1,2,null,3,null,4]) → 3

// Linear tree (all right children)
diameterOfBinaryTree([1,null,2,null,3]) → 2

// Balanced tree
diameterOfBinaryTree([1,2,3,4,5,6,7]) → 4

// Diameter not through root
//        1
//       / \
//      2   3
//     /
//    4
// Diameter is 4→2→1→3 (length 3)
diameterOfBinaryTree([1,2,3,4]) → 3
```

## Related Problems

- **Maximum Depth of Binary Tree** - Height vs diameter
- **Balanced Binary Tree** - Check height balance
- **Binary Tree Maximum Path Sum** - Find path with max value sum
- **Longest Path in Tree** - General path finding
- **Tree Diameter** - Graph version of this problem

