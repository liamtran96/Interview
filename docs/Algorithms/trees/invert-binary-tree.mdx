---
sidebar_position: 1
difficulty: Easy
tags: [trees, recursion, inversion, amazon, google]
leetcode_url: https://leetcode.com/problems/invert-binary-tree/
companies: [Amazon, Google, Microsoft, Meta, Apple]
pattern: "Trees"
---

import AlgorithmProblem from '@site/src/components/AlgorithmProblem';

# Invert Binary Tree

<AlgorithmProblem
  title="Invert Binary Tree"
  difficulty="Easy"
  description={`
<p>Given the <code>root</code> of a binary tree, invert the tree, and return its <strong>root</strong>.</p>
<p>Inverting a tree means swapping the left and right child of every node.</p>
<h4>Constraints:</h4>
<ul>
  <li>The number of nodes in the tree is in the range [0, 100]</li>
  <li>-100 ≤ Node.val ≤ 100</li>
</ul>
`}
  examples={[
    {
      input: 'root = [4,2,7,1,3,6,9]',
      output: '[4,7,2,9,6,3,1]'
    },
    {
      input: 'root = [2,1,3]',
      output: '[2,3,1]'
    },
    {
      input: 'root = []',
      output: '[]'
    }
  ]}
  starterCode={`class TreeNode {
  constructor(val = 0, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

function invertTree(root) {
  // TODO: Invert the binary tree
  return root;
}`}
  solution={`class TreeNode {
  constructor(val = 0, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

function invertTree(root) {
  // Base case: empty tree
  if (root === null) return null;

  // Swap left and right children
  [root.left, root.right] = [root.right, root.left];

  // Recursively invert left and right subtrees
  invertTree(root.left);
  invertTree(root.right);

  return root;
}`}
  testCases={[
    {
      input: [[[4, 2, 7, 1, 3, 6, 9]]],
      expected: [4, 7, 2, 9, 6, 3, 1],
      description: 'Invert a complete binary tree'
    },
    {
      input: [[[2, 1, 3]]],
      expected: [2, 3, 1],
      description: 'Invert a tree with 3 nodes'
    },
    {
      input: [null],
      expected: null,
      description: 'Empty tree'
    },
    {
      input: [[[1]]],
      expected: [1],
      description: 'Single node (no change)'
    },
    {
      input: [[[1, 2]]],
      expected: [1, null, 2],
      description: 'Left child becomes right'
    },
    {
      input: [[[1, null, 2]]],
      expected: [1, 2],
      description: 'Right child becomes left'
    }
  ]}
  functionName="invertTree"
/>

## Solution Explanation

### Approach 1: Recursive (Most Elegant) ✅

**Time Complexity:** O(n) - visit each node once
**Space Complexity:** O(h) - recursion stack, where h is height

Recursively invert left and right subtrees:

```javascript
function invertTree(root) {
  if (root === null) return null;

  // Swap children
  [root.left, root.right] = [root.right, root.left];

  // Recurse on both subtrees
  invertTree(root.left);
  invertTree(root.right);

  return root;
}
```

**How it works:**

```
Original:
    4
   / \
  2   7
 / \ / \
1  3 6  9

Step 1: Swap at root 4
    4
   / \
  7   2

Step 2: Recurse on left (7)
    7
   / \
  9   6

Step 3: Recurse on right (2)
    2
   / \
  3   1

Result:
    4
   / \
  7   2
 / \ / \
9  6 3  1
```

### Approach 2: Iterative with Queue (BFS)

**Time Complexity:** O(n)
**Space Complexity:** O(w) - width of tree (queue size)

Use a queue to traverse level by level:

```javascript
function invertTree(root) {
  if (root === null) return null;

  const queue = [root];

  while (queue.length > 0) {
    const node = queue.shift();

    // Swap children
    [node.left, node.right] = [node.right, node.left];

    // Add children to queue for processing
    if (node.left !== null) queue.push(node.left);
    if (node.right !== null) queue.push(node.right);
  }

  return root;
}
```

### Approach 3: Iterative with Stack (DFS)

**Time Complexity:** O(n)
**Space Complexity:** O(h) - height of tree (stack size)

Use a stack for post-order traversal:

```javascript
function invertTree(root) {
  if (root === null) return null;

  const stack = [root];

  while (stack.length > 0) {
    const node = stack.pop();

    // Swap children
    [node.left, node.right] = [node.right, node.left];

    // Push children onto stack
    if (node.right !== null) stack.push(node.right);
    if (node.left !== null) stack.push(node.left);
  }

  return root;
}
```

## Comparison of Approaches

| Approach | Time | Space | Best For | Simplicity |
|----------|------|-------|----------|-----------|
| Recursive | O(n) | O(h) | **Most interviews** | Easy |
| BFS Queue | O(n) | O(w) | Level-by-level | Medium |
| DFS Stack | O(n) | O(h) | Iterative preference | Medium |

## Common Mistakes

❌ **Forgetting the base case:**
```javascript
function invertTree(root) {
  [root.left, root.right] = [root.right, root.left];  // ERROR if root is null!
  invertTree(root.left);
  invertTree(root.right);
  return root;
}
```

✅ **Check for null first:**
```javascript
function invertTree(root) {
  if (root === null) return null;  // Base case
  [root.left, root.right] = [root.right, root.left];
  invertTree(root.left);
  invertTree(root.right);
  return root;
}
```

---

❌ **Only swapping without recursing:**
```javascript
function invertTree(root) {
  if (root === null) return null;
  [root.left, root.right] = [root.right, root.left];
  return root;  // ERROR: subtrees not inverted!
}
```

✅ **Recurse on both subtrees:**
```javascript
function invertTree(root) {
  if (root === null) return null;
  [root.left, root.right] = [root.right, root.left];
  invertTree(root.left);    // Invert left subtree
  invertTree(root.right);   // Invert right subtree
  return root;
}
```

---

❌ **Creating new nodes instead of modifying:**
```javascript
function invertTree(root) {
  return new TreeNode(root.val, invertTree(root.right), invertTree(root.left));
  // Unnecessary memory usage
}
```

✅ **Modify in place:**
```javascript
function invertTree(root) {
  if (root === null) return null;
  [root.left, root.right] = [root.right, root.left];  // O(1) swap
  invertTree(root.left);
  invertTree(root.right);
  return root;
}
```

## Interview Tips

**What to mention:**
1. **Recursive approach:** Most intuitive and clean
2. **Base case:** Null nodes don't need inversion
3. **Swap operation:** Simple destructuring assignment
4. **Post-order traversal:** Process children first, then node

**Follow-up questions:**

**Q: Can you do it iteratively?**
A: Yes! Use a queue (BFS) or stack (DFS) to traverse without recursion.

**Q: What about modifying vs creating new tree?**
A: Recursive approach modifies in place (O(1) space for swaps). We could create new tree with copied nodes if needed.

**Q: What's the time complexity?**
A: O(n) - must visit every node to invert it.

## Edge Cases

```javascript
// Empty tree
invertTree(null) → null

// Single node
invertTree(1) → 1 (no change)

// Left child only
invertTree(1 ← 2) → 1 → 2

// Right child only
invertTree(1 → 2) → 1 ← 2

// Already inverted
invertTree([1, 3, 2]) → [1, 2, 3]
```

## Related Problems

- **Same Tree** - Compare two trees
- **Symmetric Tree** - Check if tree is mirror of itself
- **Binary Tree Inorder Traversal** - Tree traversal
- **Flatten Binary Tree to Linked List** - Tree transformation

