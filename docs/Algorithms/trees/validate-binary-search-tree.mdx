---
sidebar_position: 7
difficulty: Medium
tags: [trees, bst, validation, amazon, google]
leetcode_url: https://leetcode.com/problems/validate-binary-search-tree/
companies: [Amazon, Google, Microsoft, Meta, Apple]
pattern: "Trees"
---

import AlgorithmProblem from '@site/src/components/AlgorithmProblem';

# Validate Binary Search Tree

<AlgorithmProblem
  title="Validate Binary Search Tree"
  difficulty="Medium"
  description={`
<p>Given the <code>root</code> of a binary tree, <strong>determine if it is a valid binary search tree (BST)</strong>.</p>
<p>A valid BST is defined as follows:</p>
<ul>
  <li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node's key.</li>
  <li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node's key.</li>
  <li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<h4>Constraints:</h4>
<ul>
  <li>The number of nodes in the tree is in the range [1, 10<sup>4</sup>]</li>
  <li>-2<sup>31</sup> ≤ Node.val ≤ 2<sup>31</sup> - 1</li>
</ul>
`}
  examples={[
    {
      input: 'root = [2,1,3]',
      output: 'true'
    },
    {
      input: 'root = [5,1,4,null,null,3,6]',
      output: 'false'
    },
    {
      input: 'root = [5]',
      output: 'true'
    }
  ]}
  starterCode={`class TreeNode {
  constructor(val = 0, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

function isValidBST(root) {
  // TODO: Validate if tree is a binary search tree
  return true;
}`}
  solution={`class TreeNode {
  constructor(val = 0, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

function isValidBST(root) {
  // Helper validates subtree with min/max bounds
  function validate(node, min, max) {
    if (node === null) return true;

    // Check if node violates BST property
    if (node.val &lt;= min || node.val &gt;= max) return false;

    // Left subtree: all values must be &lt; node.val
    // Right subtree: all values must be &gt; node.val
    return (
      validate(node.left, min, node.val) &amp;&amp;
      validate(node.right, node.val, max)
    );
  }

  return validate(root, -Infinity, Infinity);
}`}
  testCases={[
    {
      input: [[[2, 1, 3]]],
      expected: true,
      description: 'Valid BST: 1 &lt; 2 &lt; 3'
    },
    {
      input: [[[5, 1, 4, null, null, 3, 6]]],
      expected: false,
      description: 'Invalid: 4 in right subtree but &lt; 5'
    },
    {
      input: [[[5]]],
      expected: true,
      description: 'Single node is valid BST'
    },
    {
      input: [[[2, 2, 2]]],
      expected: false,
      description: 'Duplicate values not allowed (must be strictly less/greater)'
    },
    {
      input: [[[10, 5, 15, null, null, 6, 20]]],
      expected: false,
      description: 'Invalid: 6 in right subtree but &lt; 10'
    },
    {
      input: [[[2, 1, 3, 0, 1, 2, 4]]],
      expected: false,
      description: 'Invalid: left child 1 equals parent boundary'
    }
  ]}
  functionName="isValidBST"
/>

## Solution Explanation

### Approach 1: Min/Max Bounds (Most Elegant) ✅

**Time Complexity:** O(n) - visit each node once
**Space Complexity:** O(h) - recursion stack, where h is height

Track valid range (min, max) for each node:

```javascript
function isValidBST(root) {
  function validate(node, min, max) {
    if (node === null) return true;

    // Current node must be in valid range
    if (node.val &lt;= min || node.val &gt;= max) return false;

    // Left subtree: values must be &lt; node.val
    // Right subtree: values must be &gt; node.val
    return (
      validate(node.left, min, node.val) &amp;&amp;
      validate(node.right, node.val, max)
    );
  }

  return validate(root, -Infinity, Infinity);
}
```

**How it works:**

```
BST:        2
           / \
          1   3

validate(2, -Inf, Inf):
  - 2 in (-Inf, Inf)? Yes ✓
  - validate(1, -Inf, 2):
    - 1 in (-Inf, 2)? Yes ✓
    - Left null: true
    - Right null: true
    - return true
  - validate(3, 2, Inf):
    - 3 in (2, Inf)? Yes ✓
    - Left null: true
    - Right null: true
    - return true
  - return true ✓

Invalid BST:    5
               / \
              1   4

validate(5, -Inf, Inf):
  - 5 in (-Inf, Inf)? Yes ✓
  - validate(1, -Inf, 5): true (left ok)
  - validate(4, 5, Inf):
    - 4 in (5, Inf)? NO ✗ (4 not &gt; 5)
    - return false ✓
```

### Approach 2: In-Order Traversal (Also Good)

**Time Complexity:** O(n)
**Space Complexity:** O(h)

In-order traversal of BST produces sorted sequence:

```javascript
function isValidBST(root) {
  let prev = -Infinity;
  let isValid = true;

  function inOrder(node) {
    if (node === null) return;

    inOrder(node.left);

    // Each node value must be greater than previous
    if (node.val &lt;= prev) {
      isValid = false;
    }
    prev = node.val;

    if (isValid) inOrder(node.right);
  }

  inOrder(root);
  return isValid;
}
```

### Approach 3: Range Tracking with Stack (Iterative)

**Time Complexity:** O(n)
**Space Complexity:** O(h)

Use stack with [node, min, max] tuples:

```javascript
function isValidBST(root) {
  const stack = [[root, -Infinity, Infinity]];

  while (stack.length > 0) {
    const [node, min, max] = stack.pop();

    if (node === null) continue;

    if (node.val &lt;= min || node.val &gt;= max) return false;

    // Push right subtree (greater values)
    stack.push([node.right, node.val, max]);
    // Push left subtree (lesser values)
    stack.push([node.left, min, node.val]);
  }

  return true;
}
```

## Comparison of Approaches

| Approach | Time | Space | Best For | Simplicity |
|----------|------|-------|----------|-----------|
| Min/Max | O(n) | O(h) | **Most elegant** | Easy |
| In-order | O(n) | O(h) | Uses BST property | Medium |
| Iterative Stack | O(n) | O(h) | No recursion | Medium |

## Common Mistakes

❌ **Checking only immediate children:**
```javascript
function isValidBST(root) {
  function validate(node) {
    if (node === null) return true;
    // Only checks direct children!
    if (node.left &amp;&amp; node.left.val &gt;= node.val) return false;
    if (node.right &amp;&amp; node.right.val &lt;= node.val) return false;
    return validate(node.left) &amp;&amp; validate(node.right);
  }
  return validate(root);
}
// Fails on: [5, 1, 4, null, null, 3, 6]
// 3 is in right subtree but &lt; 5!
```

✅ **Check entire range constraint:**
```javascript
function isValidBST(root) {
  function validate(node, min, max) {
    if (node === null) return true;
    if (node.val &lt;= min || node.val &gt;= max) return false;
    return (
      validate(node.left, min, node.val) &amp;&amp;
      validate(node.right, node.val, max)
    );
  }
  return validate(root, -Infinity, Infinity);
}
```

---

❌ **Using &lt;= and &gt;= instead of &lt; and &gt;:**
```javascript
// Invalid: allows duplicates in BST
if (node.val &lt; min || node.val &gt; max) return false;
```

✅ **BST definition disallows duplicates:**
```javascript
// Correct: strictly less/greater (no equals)
if (node.val &lt;= min || node.val &gt;= max) return false;
```

---

❌ **Not handling edge case of equal values:**
```javascript
function isValidBST(root) {
  // [2, 2, 2] should return false
  // But simple comparison might miss this
}
```

✅ **Strict inequality handles duplicates:**
```javascript
function validate(node, min, max) {
  if (node === null) return true;
  if (node.val &lt;= min || node.val &gt;= max) return false;  // &lt;= catches duplicates
  return (
    validate(node.left, min, node.val) &amp;&amp;
    validate(node.right, node.val, max)
  );
}
```

## Interview Tips

**What to mention:**
1. **Key insight:** Each node constrains entire subtree
2. **Range tracking:** Use min/max bounds for efficiency
3. **Efficiency:** One pass with validation
4. **Edge case:** Duplicates not allowed in BST

**Follow-up questions:**

**Q: What if duplicates are allowed?**
A: Change to `&lt;= max` instead of `&lt; max`, similar for min.

**Q: Can you do in-order traversal approach?**
A: Yes, but need to track previous value instead of bounds.

**Q: What about very large values (2³¹)?**
A: Use -Infinity and Infinity (handles edge case).

## Edge Cases

```javascript
// Single node
isValidBST([1]) → true

// Equal values
isValidBST([1, 1, 1]) → false

// Valid simple BST
isValidBST([2, 1, 3]) → true

// Invalid by right subtree
isValidBST([5, 1, 4, null, null, 3, 6]) → false

// Deep left skew (valid)
isValidBST([1, null, 2, null, 3]) → true

// Min/Max boundary
isValidBST([0, -1, 0]) → false (duplicate 0)
isValidBST([-2147483648]) → true (min int)
isValidBST([2147483647]) → true (max int)
```

## Related Problems

- **Validate Binary Search Tree** - This problem
- **Lowest Common Ancestor of BST** - Use BST property
- **Convert BST to Greater Sum Tree** - BST traversal
- **Kth Smallest Element in BST** - In-order traversal
- **Recover Binary Search Tree** - Find swapped nodes

