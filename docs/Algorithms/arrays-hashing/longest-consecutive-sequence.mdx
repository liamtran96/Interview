---
sidebar_position: 8
difficulty: Medium
tags: [arrays, hash-table, union-find, google, amazon]
leetcode_url: https://leetcode.com/problems/longest-consecutive-sequence/
companies: [Google, Amazon, Meta, Microsoft, Apple]
pattern: "Arrays & Hashing"
---

import AlgorithmProblem from '@site/src/components/AlgorithmProblem';

# Longest Consecutive Sequence

<AlgorithmProblem
  title="Longest Consecutive Sequence"
  difficulty="Medium"
  description={`
<p>Given an unsorted array of integers <code>nums</code>, return the length of the longest consecutive elements sequence.</p>
<p>You must write an algorithm that runs in <strong>O(n)</strong> time.</p>
<h4>Constraints:</h4>
<ul>
  <li>0 ≤ nums.length ≤ 10<sup>5</sup></li>
  <li>-10<sup>9</sup> ≤ nums[i] ≤ 10<sup>9</sup></li>
</ul>
`}
  examples={[
    {
      input: 'nums = [100,4,200,1,3,2]',
      output: '4',
      explanation: 'The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.'
    },
    {
      input: 'nums = [0,3,7,2,5,8,4,6,0,1]',
      output: '9',
      explanation: 'The longest consecutive sequence is [0,1,2,3,4,5,6,7,8].'
    },
    {
      input: 'nums = []',
      output: '0',
      explanation: 'Empty array has no sequence.'
    }
  ]}
  starterCode={`function longestConsecutive(nums) {
  // Write your code here

}`}
  solution={`function longestConsecutive(nums) {
  if (nums.length === 0) return 0;

  const numSet = new Set(nums);
  let maxLength = 0;

  for (const num of numSet) {
    // Only start counting if num is the beginning of a sequence
    if (!numSet.has(num - 1)) {
      let currentNum = num;
      let currentLength = 1;

      // Count consecutive numbers
      while (numSet.has(currentNum + 1)) {
        currentNum++;
        currentLength++;
      }

      maxLength = Math.max(maxLength, currentLength);
    }
  }

  return maxLength;
}`}
  testCases={[
    {
      input: [[100,4,200,1,3,2]],
      expected: 4,
      description: 'Sequence [1,2,3,4]'
    },
    {
      input: [[0,3,7,2,5,8,4,6,0,1]],
      expected: 9,
      description: 'Sequence [0,1,2,3,4,5,6,7,8]'
    },
    {
      input: [[]],
      expected: 0,
      description: 'Empty array'
    },
    {
      input: [[1]],
      expected: 1,
      description: 'Single element'
    },
    {
      input: [[1,2,0,1]],
      expected: 3,
      description: 'With duplicates [0,1,2]'
    },
    {
      input: [[9,1,4,7,3,-1,0,5,8,-2,6]],
      expected: 7,
      description: 'Negative numbers included [-2,-1,0,1,3,4,5]'
    },
    {
      input: [[1,3,5,7,9]],
      expected: 1,
      description: 'No consecutive numbers'
    }
  ]}
  functionName="longestConsecutive"
/>

## Solution Explanation

### Approach 1: Sorting (Not Optimal)

**Time:** O(n log n)
**Space:** O(1) or O(n) depending on sort

```javascript
function longestConsecutive(nums) {
  if (nums.length === 0) return 0;

  nums.sort((a, b) => a - b);

  let maxLength = 1;
  let currentLength = 1;

  for (let i = 1; i < nums.length; i++) {
    if (nums[i] === nums[i - 1]) {
      continue; // Skip duplicates
    } else if (nums[i] === nums[i - 1] + 1) {
      currentLength++;
    } else {
      maxLength = Math.max(maxLength, currentLength);
      currentLength = 1;
    }
  }

  return Math.max(maxLength, currentLength);
}
```

**Why not optimal?** Sorting is O(n log n), violates O(n) requirement.

### Approach 2: Hash Set (Optimal) ✅

**Time:** O(n)
**Space:** O(n)

```javascript
function longestConsecutive(nums) {
  if (nums.length === 0) return 0;

  const numSet = new Set(nums);
  let maxLength = 0;

  for (const num of numSet) {
    // Only check sequences starting from their beginning
    if (!numSet.has(num - 1)) {
      let currentNum = num;
      let currentLength = 1;

      // Extend sequence
      while (numSet.has(currentNum + 1)) {
        currentNum++;
        currentLength++;
      }

      maxLength = Math.max(maxLength, currentLength);
    }
  }

  return maxLength;
}
```

**How it works:**

1. **Create hash set** for O(1) lookups
2. **For each number**, check if it's the start of a sequence
3. **Only process if** `num - 1` doesn't exist (ensures we start from beginning)
4. **Count consecutive** numbers using while loop
5. **Update max length**

**Key insight:** Only start counting from sequence beginnings to avoid duplicate work.

**Example walkthrough:**

```
nums = [100, 4, 200, 1, 3, 2]

Step 1: Create set
  numSet = {100, 4, 200, 1, 3, 2}

Step 2: Check each number
  100: numSet.has(99)? No → Start sequence
       100, 101? No
       Length = 1

  4: numSet.has(3)? Yes → Skip (not sequence start)

  200: numSet.has(199)? No → Start sequence
       200, 201? No
       Length = 1

  1: numSet.has(0)? No → Start sequence
     1, 2? Yes → continue
     2, 3? Yes → continue
     3, 4? Yes → continue
     4, 5? No → stop
     Length = 4 ✓

  3: numSet.has(2)? Yes → Skip

  2: numSet.has(1)? Yes → Skip

Result: maxLength = 4
```

**Why O(n) time?**

Even though there's a nested while loop, each number is visited at most twice:
- Once in the outer for loop
- Once in the inner while loop (only for sequence continuations)

Total operations: O(n + n) = O(n)

### Alternative: Union-Find

**Time:** O(n α(n)) where α is inverse Ackermann
**Space:** O(n)

More complex, usually not needed for interviews.

## Common Mistakes

❌ Using sorting (violates O(n) requirement)
```javascript
nums.sort((a, b) => a - b); // O(n log n)
```

✅ Use hash set for O(1) lookups
```javascript
const numSet = new Set(nums);
```

❌ Checking all numbers for sequences
```javascript
for (const num of numSet) {
  // This will count same sequence multiple times!
  while (numSet.has(currentNum + 1)) { ... }
}
```

✅ Only start from sequence beginnings
```javascript
if (!numSet.has(num - 1)) {
  // Only start if this is the beginning
}
```

❌ Not handling duplicates
```javascript
// Duplicates in array could affect counting
```

✅ Use Set to automatically handle duplicates
```javascript
const numSet = new Set(nums); // Removes duplicates
```

## Interview Tips

**When discussing:**
1. Start with sorting approach and note O(n log n) limitation
2. Explain hash set enables O(1) lookups
3. Emphasize checking for sequence start (num - 1)
4. Walk through why this is O(n) not O(n²)
5. Mention Set automatically handles duplicates

**Follow-up questions:**
- Why is it O(n) with nested loops? → Each element visited max twice
- Can you do it in O(1) space? → Not really, need hash set
- What about duplicates? → Set handles them automatically
- What if array is sorted? → Could use O(1) space with two pointers
- How to find all sequences? → Store them during iteration

**Key insights:**
- Hash set provides O(1) membership testing
- Starting only from sequence beginnings avoids duplicate work
- Set iteration + while loop still O(n) total
- This is a classic "intelligent iteration" problem
