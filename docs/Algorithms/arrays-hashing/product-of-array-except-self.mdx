---
sidebar_position: 5
difficulty: Medium
tags: [arrays, prefix-sum, amazon, meta]
leetcode_url: https://leetcode.com/problems/product-of-array-except-self/
companies: [Amazon, Meta, Google, Microsoft, Apple]
pattern: "Arrays & Hashing"
---

import AlgorithmProblem from '@site/src/components/AlgorithmProblem';

# Product of Array Except Self

<AlgorithmProblem
  title="Product of Array Except Self"
  difficulty="Medium"
  description={`
<p>Given an integer array <code>nums</code>, return an array <code>answer</code> such that <code>answer[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</p>
<p>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</p>
<p>You must write an algorithm that runs in <strong>O(n)</strong> time and without using the division operation.</p>
<h4>Constraints:</h4>
<ul>
  <li>2 ≤ nums.length ≤ 10<sup>5</sup></li>
  <li>-30 ≤ nums[i] ≤ 30</li>
  <li>The product of any prefix or suffix of <code>nums</code> is guaranteed to fit in a 32-bit integer.</li>
</ul>
<p><strong>Follow up:</strong> Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space.)</p>
`}
  examples={[
    {
      input: 'nums = [1,2,3,4]',
      output: '[24,12,8,6]',
      explanation: 'answer[0] = 2*3*4 = 24, answer[1] = 1*3*4 = 12, answer[2] = 1*2*4 = 8, answer[3] = 1*2*3 = 6'
    },
    {
      input: 'nums = [-1,1,0,-3,3]',
      output: '[0,0,9,0,0]',
      explanation: 'Product containing 0 will be 0. For index 2, product is (-1)*1*(-3)*3 = 9'
    }
  ]}
  starterCode={`function productExceptSelf(nums) {
  // Write your code here

}`}
  solution={`function productExceptSelf(nums) {
  // O(n) time, O(1) space (output array doesn't count)
  const n = nums.length;
  const answer = new Array(n);

  // Calculate left products
  answer[0] = 1;
  for (let i = 1; i < n; i++) {
    answer[i] = answer[i - 1] * nums[i - 1];
  }

  // Calculate right products and multiply with left
  let right = 1;
  for (let i = n - 1; i >= 0; i--) {
    answer[i] *= right;
    right *= nums[i];
  }

  return answer;
}`}
  testCases={[
    {
      input: [[1,2,3,4]],
      expected: [24,12,8,6],
      description: 'Basic case with positive numbers'
    },
    {
      input: [[-1,1,0,-3,3]],
      expected: [0,0,9,0,0],
      description: 'Array containing zero'
    },
    {
      input: [[2,3]],
      expected: [3,2],
      description: 'Minimum length array'
    },
    {
      input: [[1,1,1,1,1]],
      expected: [1,1,1,1,1],
      description: 'All ones'
    },
    {
      input: [[-1,-2,-3,-4]],
      expected: [-24,-12,-8,-6],
      description: 'All negative numbers'
    },
    {
      input: [[0,0]],
      expected: [0,0],
      description: 'Multiple zeros'
    }
  ]}
  functionName="productExceptSelf"
/>

## Solution Explanation

### Approach 1: Brute Force (Not Allowed)

**Time:** O(n²)
**Space:** O(1)

```javascript
function productExceptSelf(nums) {
  const result = [];

  for (let i = 0; i < nums.length; i++) {
    let product = 1;
    for (let j = 0; j < nums.length; j++) {
      if (i !== j) {
        product *= nums[j];
      }
    }
    result.push(product);
  }

  return result;
}
```

**Why not optimal?** O(n²) time complexity is too slow.

### Approach 2: Division (Not Allowed)

```javascript
// Calculate total product, divide by current element
// But problem explicitly says: NO DIVISION
```

### Approach 3: Prefix and Suffix Arrays

**Time:** O(n)
**Space:** O(n)

```javascript
function productExceptSelf(nums) {
  const n = nums.length;
  const left = new Array(n);
  const right = new Array(n);
  const answer = new Array(n);

  // Left products
  left[0] = 1;
  for (let i = 1; i < n; i++) {
    left[i] = left[i - 1] * nums[i - 1];
  }

  // Right products
  right[n - 1] = 1;
  for (let i = n - 2; i >= 0; i--) {
    right[i] = right[i + 1] * nums[i + 1];
  }

  // Combine
  for (let i = 0; i < n; i++) {
    answer[i] = left[i] * right[i];
  }

  return answer;
}
```

### Approach 4: Optimized Space (Optimal) ✅

**Time:** O(n)
**Space:** O(1) (output doesn't count)

```javascript
function productExceptSelf(nums) {
  const n = nums.length;
  const answer = new Array(n);

  // Step 1: Calculate left products in answer array
  answer[0] = 1;
  for (let i = 1; i < n; i++) {
    answer[i] = answer[i - 1] * nums[i - 1];
  }

  // Step 2: Calculate right products on the fly
  let right = 1;
  for (let i = n - 1; i >= 0; i--) {
    answer[i] *= right;
    right *= nums[i];
  }

  return answer;
}
```

**How it works:**

1. **Left pass**: Store product of all elements to the left
2. **Right pass**: Multiply by product of all elements to the right

**Example walkthrough:**

```
nums = [1, 2, 3, 4]

After left pass:
  answer[0] = 1           (no elements to left)
  answer[1] = 1           (1)
  answer[2] = 1*2         (1*2 = 2)
  answer[3] = 1*2*3       (1*2*3 = 6)
  answer = [1, 1, 2, 6]

After right pass:
  i=3: answer[3] *= 1,     right = 4    → answer = [1, 1, 2, 6]
  i=2: answer[2] *= 4,     right = 12   → answer = [1, 1, 8, 6]
  i=1: answer[1] *= 12,    right = 24   → answer = [1, 12, 8, 6]
  i=0: answer[0] *= 24,    right = 24   → answer = [24, 12, 8, 6]

Result: [24, 12, 8, 6]
```

## Common Mistakes

❌ Using division
```javascript
const total = nums.reduce((a, b) => a * b);
answer[i] = total / nums[i]; // Not allowed!
```

✅ Use prefix/suffix products
```javascript
answer[i] = leftProduct[i] * rightProduct[i];
```

❌ Not handling zeros correctly
```javascript
// Multiplying by zero gives 0 - this is correct!
// But need to handle edge cases properly
```

✅ Algorithm naturally handles zeros
```javascript
// When zero is encountered, all products except
// that position will be 0
```

## Interview Tips

**When discussing:**
1. Mention division approach is not allowed
2. Explain prefix/suffix product concept
3. Show how to optimize from O(n) space to O(1)
4. Walk through example with clear left/right products
5. Discuss how zeros are handled naturally

**Follow-up questions:**
- Can you use division? → No, problem forbids it
- What if array contains zeros? → Algorithm handles naturally
- Space complexity? → O(1) if output doesn't count
- What about overflow? → Problem guarantees 32-bit fit
