---
sidebar_position: 2
difficulty: Easy
tags: [graphs, dfs, bfs, hash-table, amazon, google, facebook]
leetcode_url: https://leetcode.com/problems/clone-graph/
companies: [Amazon, Google, Facebook, Microsoft, Apple]
pattern: "Graphs"
---

import AlgorithmProblem from '@site/src/components/AlgorithmProblem';

# Clone Graph

<AlgorithmProblem
  title="Clone Graph"
  difficulty="Easy"
  description={`
<p>Given a reference of a node in a <strong>connected</strong> undirected graph.</p>
<p>Return a <strong>deep copy</strong> (clone) of the graph.</p>
<p>Each node in the graph contains a <code>val</code> (<code>int</code>) and a list (<code>List[Node]</code>) of its <code>neighbors</code>.</p>
<p><code>class Node {<br/>    public int val;<br/>    public List&lt;Node&gt; neighbors;<br/>}</code></p>
<h4>Constraints:</h4>
<ul>
  <li>The number of nodes in the graph is in the range [1, 100].</li>
  <li>1 &lt;= Node.val &lt;= 100</li>
  <li>Each node <code>neighbors</code> is a list of nodes with no duplicates.</li>
  <li>There is no self-loop and no duplicate edges in the graph.</li>
  <li>The graph is connected and all nodes can be visited starting from the given node.</li>
</ul>
`}
  examples={[
    {
      input: 'adjList = [[2,4],[1,3],[2,4],[1,3]]',
      output: '[[2,4],[1,3],[2,4],[1,3]]',
      explanation: 'The graph has 4 nodes. Node 1\'s neighbors are 2 and 4; Node 2\'s neighbors are 1 and 3; Node 3\'s neighbors are 2 and 4; Node 4\'s neighbors are 1 and 3.'
    },
    {
      input: 'adjList = [[]]',
      output: '[[]]',
      explanation: 'A graph with a single isolated node.'
    },
    {
      input: 'adjList = []',
      output: '[]',
      explanation: 'An empty graph.'
    }
  ]}
  starterCode={`class Node {
  constructor(val = 0, neighbors = []) {
    this.val = val;
    this.neighbors = neighbors;
  }
}

function cloneGraph(node) {
  // Write your code here
  return null;
}`}
  solution={`class Node {
  constructor(val = 0, neighbors = []) {
    this.val = val;
    this.neighbors = neighbors;
  }
}

function cloneGraph(node) {
  // DFS approach with hash map to track visited nodes
  // Time: O(N + E) where N = nodes, E = edges
  // Space: O(N) for map and recursion stack

  if (!node) return null;

  const map = new Map();  // Map of original node to cloned node

  function dfs(original) {
    // If already cloned, return the cloned node
    if (map.has(original)) {
      return map.get(original);
    }

    // Create new clone node
    const clone = new Node(original.val, []);
    map.set(original, clone);

    // Clone all neighbors recursively
    for (const neighbor of original.neighbors) {
      clone.neighbors.push(dfs(neighbor));
    }

    return clone;
  }

  return dfs(node);
}`}
  testCases={[
    {
      input: [[2, 4], [1, 3], [2, 4], [1, 3]],
      expected: [[2, 4], [1, 3], [2, 4], [1, 3]],
      description: 'Complete graph with 4 nodes'
    },
    {
      input: [[]],
      expected: [[]],
      description: 'Single isolated node'
    },
    {
      input: [[2], [1]],
      expected: [[2], [1]],
      description: 'Two connected nodes'
    },
    {
      input: [[1, 3], [2], [1]],
      expected: [[1, 3], [2], [1]],
      description: 'Three-node graph with cycle'
    },
    {
      input: [[2, 3, 4], [1], [1], [1]],
      expected: [[2, 3, 4], [1], [1], [1]],
      description: 'Star graph (one center connected to all)'
    },
    {
      input: [[2], [3], [1]],
      expected: [[2], [3], [1]],
      description: 'Linear chain of 3 nodes'
    }
  ]}
  functionName="cloneGraph"
/>

## Solution Explanation

### Approach 1: DFS with Hash Map ✅

**Time Complexity:** O(N + E) where N = nodes, E = edges
**Space Complexity:** O(N) for hash map and recursion stack

Use DFS to traverse the graph and create clones while tracking visited nodes:

```javascript
class Node {
  constructor(val = 0, neighbors = []) {
    this.val = val;
    this.neighbors = neighbors;
  }
}

function cloneGraph(node) {
  if (!node) return null;

  const map = new Map();  // Map original nodes to cloned nodes

  function dfs(original) {
    // If we've already cloned this node, return it
    if (map.has(original)) {
      return map.get(original);
    }

    // Create a new clone node (without neighbors yet)
    const clone = new Node(original.val, []);
    map.set(original, clone);

    // Clone all neighbors
    for (const neighbor of original.neighbors) {
      clone.neighbors.push(dfs(neighbor));
    }

    return clone;
  }

  return dfs(node);
}
```

**How it works:**

```
Original Graph (4 nodes):
1 -- 2
|    |
4 -- 3

DFS Traversal:
1. dfs(node1): Create clone1, add to map
2.   neighbor=node2: dfs(node2): Create clone2, add to map
3.     neighbor=node1: already in map, return clone1
4.     neighbor=node3: dfs(node3): Create clone3, add to map
5.       neighbor=node2: already in map, return clone2
6.       neighbor=node4: dfs(node4): Create clone4, add to map
7.         neighbor=node1: already in map, return clone1
8.         neighbor=node3: already in map, return clone3
9.       return clone4
10.    return clone3
11.  return clone2
12. neighbor=node4: already in map, return clone4
13. return clone1

Result: Complete cloned graph with all connections preserved
```

### Approach 2: BFS with Hash Map ✅

**Time Complexity:** O(N + E)
**Space Complexity:** O(N) for hash map and queue

```javascript
function cloneGraph(node) {
  if (!node) return null;

  const map = new Map();
  const queue = [node];

  // Create clone of starting node
  map.set(node, new Node(node.val, []));

  while (queue.length > 0) {
    const original = queue.shift();
    const clone = map.get(original);

    // Clone all neighbors
    for (const neighbor of original.neighbors) {
      if (!map.has(neighbor)) {
        // Create clone for new neighbor
        map.set(neighbor, new Node(neighbor.val, []));
        queue.push(neighbor);
      }

      // Add cloned neighbor to current clone
      clone.neighbors.push(map.get(neighbor));
    }
  }

  return map.get(node);
}
```

**BFS Approach Benefits:**
- Avoids potential stack overflow with deep graphs
- More intuitive for graph traversal
- Processes nodes level by level

### Key Concepts

1. **Deep Copy**: Create completely new graph, not just reference copy
2. **Visited Tracking**: Use map to track original→clone pairs to avoid infinite loops
3. **Cycle Handling**: Cycles don't cause problems because we check map before recursing
4. **Two-Phase Creation**:
   - Phase 1: Create node and add to map (before processing neighbors)
   - Phase 2: Clone neighbors and add to neighbors list

## Common Mistakes

❌ Shallow copy (just referencing original nodes):
```javascript
// Wrong - returns original graph, not a clone
function cloneGraph(node) {
  return node;  // This is not a clone!
}
```

❌ Not tracking visited nodes:
```javascript
// Wrong - infinite recursion due to cycles
function dfs(node) {
  for (const neighbor of node.neighbors) {
    dfs(neighbor);  // Will visit same node infinitely
  }
}
```

❌ Adding node to map after processing neighbors:
```javascript
// Wrong - map not populated in time for self-references
function dfs(original) {
  const clone = new Node(original.val, []);

  for (const neighbor of original.neighbors) {
    clone.neighbors.push(dfs(neighbor));  // May not find clone in map yet
  }

  map.set(original, clone);  // Too late!
}
```

✅ Correct approach:
```javascript
function dfs(original) {
  // Check if already cloned
  if (map.has(original)) {
    return map.get(original);
  }

  // Create and register clone BEFORE processing neighbors
  const clone = new Node(original.val, []);
  map.set(original, clone);

  // Now safe to process neighbors
  for (const neighbor of original.neighbors) {
    clone.neighbors.push(dfs(neighbor));
  }

  return clone;
}
```

## Interview Tips

**When discussing this problem:**
1. Recognize: "This is a graph cloning problem with potential cycles"
2. Key challenge: "We need to track which nodes we've cloned to avoid infinite loops"
3. Explain approach: "Use DFS with a hash map to create clones while tracking visited nodes"
4. Implementation: "Add node to map BEFORE processing neighbors to handle cycles"
5. Complexity: "O(N + E) time for traversing all nodes and edges, O(N) space for map"

**Key talking points:**
- "We need a deep copy, not just referencing the original graph"
- "Hash map prevents infinite recursion when cycles exist"
- "Must add to map before processing neighbors to handle self-references"
- "Each node visited exactly once, each edge processed once"

**What if interviewer asks:**
- **"What if node is null?"** - Return null immediately
- **"Can we use BFS instead of DFS?"** - Yes, both work identically
- **"What's the difference from tree cloning?"** - Graphs have cycles, need visited tracking
- **"Can we use the original nodes directly?"** - No, we need a deep copy

**Related LeetCode Problems:**
- Copy List with Random Pointer (similar hash map technique)
- Serialize and Deserialize N-ary Tree
- Deepest Leaves Sum
- Graph Bipartite

**Follow-up variations:**
- Clone directed acyclic graph (DAG)
- Clone weighted graph
- Clone with custom properties on nodes
