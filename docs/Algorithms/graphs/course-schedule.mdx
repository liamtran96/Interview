---
sidebar_position: 4
difficulty: Easy
tags: [graphs, dfs, bfs, topological-sort, amazon, google, facebook]
leetcode_url: https://leetcode.com/problems/course-schedule/
companies: [Amazon, Google, Facebook, Microsoft, Apple]
pattern: "Graphs"
---

import AlgorithmProblem from '@site/src/components/AlgorithmProblem';

# Course Schedule

<AlgorithmProblem
  title="Course Schedule"
  difficulty="Easy"
  description={`
<p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [ai, bi]</code> indicates that you <strong>must take course </strong><code>bi</code><strong> first if you want to take course </strong><code>ai</code>.</p>
<p>For example, the pair <code>[0, 1]</code> indicates that to take course 0 you have to first take course 1.</p>
<p>Return <code>true</code> if you can finish all courses. Otherwise, return <code>false</code>.</p>
<h4>Constraints:</h4>
<ul>
  <li>1 &lt;= numCourses &lt;= 2000</li>
  <li>0 &lt;= prerequisites.length &lt;= 5000</li>
  <li>prerequisites[i].length == 2</li>
  <li>0 &lt;= ai, bi &lt; numCourses</li>
  <li>All the pairs prerequisites[ai, bi] are unique.</li>
</ul>
`}
  examples={[
    {
      input: 'numCourses = 2, prerequisites = [[1,0]]',
      output: 'true',
      explanation: 'Take course 0 first, then course 1.'
    },
    {
      input: 'numCourses = 2, prerequisites = [[1,0],[0,1]]',
      output: 'false',
      explanation: 'Circular dependency: must take 0 to take 1, and 1 to take 0.'
    },
    {
      input: 'numCourses = 3, prerequisites = [[0,1],[0,2],[1,3],[1,4],[3,2]]',
      output: 'true',
      explanation: 'Complex DAG with valid ordering.'
    }
  ]}
  starterCode={`function canFinish(numCourses, prerequisites) {
  // Write your code here
  return true;
}`}
  solution={`function canFinish(numCourses, prerequisites) {
  // DFS approach to detect cycles in directed graph
  // Time: O(N + E) where N = courses, E = prerequisites
  // Space: O(N + E) for graph and visited states

  // Build adjacency list
  const graph = Array.from({ length: numCourses }, () => []);
  for (const [course, prereq] of prerequisites) {
    graph[course].push(prereq);
  }

  // 0 = unvisited, 1 = visiting, 2 = visited
  const visited = new Array(numCourses).fill(0);

  function hasCycle(course) {
    if (visited[course] === 1) {
      return true;  // Found cycle (back edge)
    }
    if (visited[course] === 2) {
      return false;  // Already processed safely
    }

    visited[course] = 1;  // Mark as visiting

    // Check all prerequisites (neighbors)
    for (const prereq of graph[course]) {
      if (hasCycle(prereq)) {
        return true;
      }
    }

    visited[course] = 2;  // Mark as visited
    return false;
  }

  // Check for cycle in each course
  for (let i = 0; i < numCourses; i++) {
    if (hasCycle(i)) {
      return false;
    }
  }

  return true;
}`}
  testCases={[
    {
      input: [2, [[1, 0]]],
      expected: true,
      description: 'Simple prerequisite: course 1 depends on 0'
    },
    {
      input: [2, [[1, 0], [0, 1]]],
      expected: false,
      description: 'Cycle: 0 and 1 depend on each other'
    },
    {
      input: [3, [[0, 1], [0, 2], [1, 3], [1, 4], [3, 2]]],
      expected: true,
      description: 'Complex valid DAG'
    },
    {
      input: [1, []],
      expected: true,
      description: 'Single course, no prerequisites'
    },
    {
      input: [3, [[1, 0], [2, 1]]],
      expected: true,
      description: 'Linear chain: 0 → 1 → 2'
    },
    {
      input: [4, [[1, 0], [2, 1], [3, 2], [0, 3]]],
      expected: false,
      description: 'Cycle in chain: 0 → 1 → 2 → 3 → 0'
    }
  ]}
  functionName="canFinish"
/>

## Solution Explanation

### Approach 1: DFS with Cycle Detection ✅

**Time Complexity:** O(N + E) where N = numCourses, E = prerequisites
**Space Complexity:** O(N + E) for graph and recursion stack

Use DFS with color-coded states to detect cycles:

```javascript
function canFinish(numCourses, prerequisites) {
  // Build adjacency list
  const graph = Array.from({ length: numCourses }, () => []);
  for (const [course, prereq] of prerequisites) {
    graph[course].push(prereq);  // course depends on prereq
  }

  // States: 0=unvisited, 1=visiting (in current path), 2=visited
  const visited = new Array(numCourses).fill(0);

  function hasCycle(course) {
    if (visited[course] === 1) {
      return true;  // Back edge = cycle!
    }
    if (visited[course] === 2) {
      return false;  // Already safe to take
    }

    visited[course] = 1;  // Mark as visiting

    // Check all prerequisites
    for (const prereq of graph[course]) {
      if (hasCycle(prereq)) {
        return true;
      }
    }

    visited[course] = 2;  // Mark as safe
    return false;
  }

  // Test each course for cycles
  for (let i = 0; i < numCourses; i++) {
    if (hasCycle(i)) {
      return false;
    }
  }

  return true;
}
```

**How DFS Cycle Detection Works:**

```
Graph: 0 → 1 → 2 (no cycle)
       ↓_____↑

Check course 0:
  visited[0] = 1 (visiting)
  Check prereq 1:
    visited[1] = 1 (visiting)
    Check prereq 2:
      visited[2] = 1 (visiting)
      No prereqs
      visited[2] = 2 (visited)
      return false
    visited[1] = 2 (visited)
    return false
  visited[0] = 2 (visited)
  return false
Result: No cycle!

---

Graph: 0 ↔ 1 (cycle)

Check course 0:
  visited[0] = 1 (visiting)
  Check prereq 1:
    visited[1] = 1 (visiting)
    Check prereq 0:
      visited[0] === 1 (BACK EDGE!)
      return true (CYCLE FOUND!)
Result: Cycle detected!
```

### Approach 2: BFS with Kahn's Algorithm ✅

**Time Complexity:** O(N + E)
**Space Complexity:** O(N + E)

Use topological sort with in-degree counting:

```javascript
function canFinish(numCourses, prerequisites) {
  // Build adjacency list and in-degree array
  const graph = Array.from({ length: numCourses }, () => []);
  const inDegree = new Array(numCourses).fill(0);

  for (const [course, prereq] of prerequisites) {
    graph[prereq].push(course);  // prereq → course
    inDegree[course]++;
  }

  // Start with courses that have no prerequisites
  const queue = [];
  for (let i = 0; i < numCourses; i++) {
    if (inDegree[i] === 0) {
      queue.push(i);
    }
  }

  let count = 0;
  while (queue.length > 0) {
    const course = queue.shift();
    count++;

    // For each course that depends on this one
    for (const nextCourse of graph[course]) {
      inDegree[nextCourse]--;
      if (inDegree[nextCourse] === 0) {
        queue.push(nextCourse);
      }
    }
  }

  // If we processed all courses, no cycle exists
  return count === numCourses;
}
```

**Kahn's Algorithm Logic:**

```
Courses: 0, 1, 2
Prerequisites: 1→0, 2→1 (0→1→2 order)

Step 1: Count in-degrees
  in-degree[0] = 1 (depends on 1)
  in-degree[1] = 1 (depends on 2)
  in-degree[2] = 0 (no dependencies)

Step 2: Start with 0-in-degree courses
  queue = [2]

Step 3: Process queue
  Process 2: count=1, neighbors=[1], in-degree[1]-=1 → 0
  Add 1 to queue: queue = [1]
  Process 1: count=2, neighbors=[0], in-degree[0]-=1 → 0
  Add 0 to queue: queue = [0]
  Process 0: count=3, neighbors=[]
  queue = []

Step 4: count === numCourses → true (no cycle!)
```

### Key Concepts

1. **Directed Acyclic Graph (DAG)**: Valid course schedule must be acyclic
2. **Cycle Detection**: Use DFS with color states to find back edges
3. **Topological Sort**: Alternative using Kahn's algorithm
4. **Graph Representation**: Build adjacency list for efficient traversal

## Common Mistakes

❌ Only checking current course visited status:
```javascript
// Wrong - doesn't detect cycles properly
const visited = new Set();
if (visited.has(course)) {
  return false;  // Might not be a cycle, could be shared dependency
}
```

❌ Not distinguishing between "visiting" and "visited":
```javascript
// Wrong - no way to detect back edges vs shared dependencies
const visited = new Set();
if (visited.has(course)) {
  return true;  // This isn't necessarily a cycle!
}
visited.add(course);
```

❌ Building graph backwards:
```javascript
// Wrong - should show who depends on whom
graph[prereq].push(course);  // Wrong direction!
```

✅ Correct approach:
```javascript
// Three states for accurate cycle detection
// 0 = unvisited
// 1 = visiting (in current DFS path)
// 2 = visited (finished processing)
const visited = new Array(numCourses).fill(0);

function hasCycle(course) {
  if (visited[course] === 1) {
    return true;  // Back edge = cycle!
  }
  if (visited[course] === 2) {
    return false;  // Safe
  }

  visited[course] = 1;  // Mark as visiting
  for (const prereq of graph[course]) {
    if (hasCycle(prereq)) {
      return true;
    }
  }
  visited[course] = 2;  // Mark as visited

  return false;
}
```

## Interview Tips

**When discussing this problem:**
1. Recognize: "This is a cycle detection problem in a directed graph"
2. Key insight: "Valid prerequisites form a DAG (directed acyclic graph)"
3. Approach: "Use DFS with three states or topological sort"
4. Complexity: "O(N + E) time and space for graph representation"

**Key talking points:**
- "Cycles in prerequisites mean impossible to complete all courses"
- "Use 3-state coloring: unvisited, visiting, visited"
- "Back edge (visiting → visiting) indicates a cycle"
- "DFS is intuitive; BFS with Kahn's is more mathematical"

**What if interviewer asks:**
- **"Difference between DFS and BFS approach?"** - DFS checks path directly, BFS counts in-degrees
- **"Can we modify input?"** - Both approaches don't need to modify
- **"What about self-loops?"** - Would be cycle (1-node cycle)
- **"What if no prerequisites?"** - All in-degree 0, all courses valid

**Related LeetCode Problems:**
- Course Schedule II (return ordering)
- Topological Sort (general problem)
- Detect Cycle in Directed Graph
- Alien Dictionary (topological sort)

**Follow-up variations:**
- Return a valid course schedule (ordering)
- Count number of cycles
- Find longest path
- Detect all cycles in graph
