---
sidebar_position: 1
difficulty: Easy
tags: [stack, string, google, amazon, facebook, microsoft]
leetcode_url: https://leetcode.com/problems/valid-parentheses/
companies: [Google, Amazon, Facebook, Microsoft, Bloomberg]
pattern: "Stack"
---

import AlgorithmProblem from '@site/src/components/AlgorithmProblem';

# Valid Parentheses

<AlgorithmProblem
  title="Valid Parentheses"
  difficulty="Easy"
  description={`
<p>Given a string <code>s</code> containing just the characters <code>'('</code>, <code>')'</code>, <code>'{'</code>, <code>'}'</code>, <code>'['</code> and <code>']'</code>, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ul>
  <li>Open brackets must be closed by the same type of brackets.</li>
  <li>Open brackets must be closed in the correct order.</li>
  <li>Every close bracket has a corresponding open bracket of the same type.</li>
</ul>
<h4>Constraints:</h4>
<ul>
  <li>1 &lt;= s.length &lt;= 10<sup>4</sup></li>
  <li>s consists of parentheses only <code>'()[]{}'</code>.</li>
</ul>
`}
  examples={[
    {
      input: 's = "()"',
      output: 'true',
      explanation: 'Simple valid pair'
    },
    {
      input: 's = "()[]{}"',
      output: 'true',
      explanation: 'Multiple valid pairs in sequence'
    },
    {
      input: 's = "(]"',
      output: 'false',
      explanation: 'Wrong closing bracket type'
    },
    {
      input: 's = "([)]"',
      output: 'false',
      explanation: 'Brackets are not closed in correct order'
    }
  ]}
  starterCode={`function isValid(s) {
  // Write your code here

}`}
  solution={`function isValid(s) {
  // Stack approach: O(n) time, O(n) space
  const stack = [];
  const pairs = {
    ')': '(',
    '}': '{',
    ']': '['
  };

  for (const char of s) {
    // If it's a closing bracket
    if (char in pairs) {
      // Check if it matches the top of stack
      if (stack.length === 0 || stack.pop() !== pairs[char]) {
        return false;
      }
    } else {
      // It's an opening bracket, push to stack
      stack.push(char);
    }
  }

  // Valid only if stack is empty (all brackets matched)
  return stack.length === 0;
}`}
  testCases={[
    {
      input: ["()"],
      expected: true,
      description: 'Simple valid pair: "()"'
    },
    {
      input: ["()[]{}"],
      expected: true,
      description: 'Multiple valid pairs: "()[]{}"'
    },
    {
      input: ["(]"],
      expected: false,
      description: 'Wrong closing bracket: "(]"'
    },
    {
      input: ["([)]"],
      expected: false,
      description: 'Wrong order: "([)]"'
    },
    {
      input: ["{[]}"],
      expected: true,
      description: 'Nested brackets: "{[]}"'
    },
    {
      input: ["(("],
      expected: false,
      description: 'Unclosed brackets: "(("'
    }
  ]}
  functionName="isValid"
/>

## Solution Explanation

### Approach 1: Brute Force with String Replacement (Not Recommended)

**Time Complexity:** O(n²)
**Space Complexity:** O(n)

Keep removing matched pairs until none remain:

```javascript
function isValid(s) {
  // Keep removing valid pairs
  while (s.includes('()') || s.includes('[]') || s.includes('{}')) {
    s = s.replace('()', '').replace('[]', '').replace('{}', '');
  }
  return s.length === 0;
}
```

**Why not use this?**
- O(n²) time complexity due to repeated string operations
- Creating new strings on each iteration is inefficient
- String replacement is not the natural way to think about matching

### Approach 2: Stack (Optimal) ✅

**Time Complexity:** O(n)
**Space Complexity:** O(n)

Use a stack to match opening brackets with closing brackets:

```javascript
function isValid(s) {
  const stack = [];
  const pairs = {
    ')': '(',
    '}': '{',
    ']': '['
  };

  for (const char of s) {
    // If it's a closing bracket
    if (char in pairs) {
      // Check if it matches the top of stack
      if (stack.length === 0 || stack.pop() !== pairs[char]) {
        return false;
      }
    } else {
      // It's an opening bracket, push to stack
      stack.push(char);
    }
  }

  // Valid only if stack is empty (all brackets matched)
  return stack.length === 0;
}
```

**How the Stack works:**

```
Input: s = "([{}])"

Step 1: '(' → Push to stack
  stack: ['(']

Step 2: '[' → Push to stack
  stack: ['(', '[']

Step 3: '{' → Push to stack
  stack: ['(', '[', '{']

Step 4: '}' → Closing bracket, pop and check
  pop '{', matches '}' ✓
  stack: ['(', '[']

Step 5: ']' → Closing bracket, pop and check
  pop '[', matches ']' ✓
  stack: ['(']

Step 6: ')' → Closing bracket, pop and check
  pop '(', matches ')' ✓
  stack: []

Result: Stack is empty → Valid! ✅
```

**Why Stack is Perfect Here:**

1. **LIFO nature**: Last opened bracket must be closed first (nested structure)
2. **Matching pairs**: Each closing bracket must match the most recent opening bracket
3. **Natural fit**: Stack operations mirror the bracket matching logic
4. **Early exit**: Can return false immediately on mismatch

### Alternative Implementation with Switch

```javascript
function isValid(s) {
  const stack = [];

  for (const char of s) {
    switch (char) {
      case '(':
      case '[':
      case '{':
        stack.push(char);
        break;
      case ')':
        if (stack.pop() !== '(') return false;
        break;
      case ']':
        if (stack.pop() !== '[') return false;
        break;
      case '}':
        if (stack.pop() !== '{') return false;
        break;
    }
  }

  return stack.length === 0;
}
```

### Key Insights

1. **Stack is the natural data structure** for matching nested structures
2. **One pass solution**: Process each character exactly once
3. **Space trade-off**: Stack can grow to n/2 in worst case (all opening brackets)
4. **Early detection**: Invalid string detected immediately on mismatch

## Common Mistakes

❌ Forgetting to check if stack is empty before popping:
```javascript
// This will return undefined if stack is empty
if (stack.pop() !== pairs[char]) return false;
```

❌ Not checking if stack is empty at the end:
```javascript
// Wrong - doesn't catch unclosed brackets like "((("
for (const char of s) { /* ... */ }
return true; // Should check stack.length === 0
```

❌ Comparing closing bracket instead of opening:
```javascript
// Wrong - should compare with opening bracket
if (stack.pop() !== char) return false;
```

✅ Correct approach checks stack and compares properly:
```javascript
if (char in pairs) {
  // Check stack not empty AND top matches
  if (stack.length === 0 || stack.pop() !== pairs[char]) {
    return false;
  }
} else {
  stack.push(char);
}

// Check all brackets were closed
return stack.length === 0;
```

## Interview Tips

**When discussing this problem:**
1. Immediately recognize it as a **stack problem** (matching/nesting)
2. Explain why stack is the right data structure (LIFO matches nesting)
3. Walk through the algorithm with a complex example like "([{}])"
4. Mention both valid and invalid cases
5. Discuss time and space complexity

**Key talking points:**
- "This is a classic stack problem because we need to match nested structures"
- "The LIFO property of stacks naturally handles the nesting order"
- "We push opening brackets and pop when we see closing brackets"
- "If the popped bracket doesn't match, the string is invalid"

**Follow-up questions you might get:**
- **What if there are other characters?** Skip non-bracket characters
- **Can you do it without extra space?** No, need stack for nested matching
- **What about just one type of bracket?** Counter would work, but stack is more general
- **How would you handle unlimited bracket types?** Same algorithm, just update the pairs map
