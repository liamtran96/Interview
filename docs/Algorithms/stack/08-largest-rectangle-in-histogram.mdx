---
sidebar_position: 8
difficulty: Hard
tags: [stack, array, monotonic-stack, google, amazon, facebook]
leetcode_url: https://leetcode.com/problems/largest-rectangle-in-histogram/
companies: [Google, Amazon, Facebook, Microsoft, Apple]
pattern: "Stack"
---

import AlgorithmProblem from '@site/src/components/AlgorithmProblem';

# Largest Rectangle in Histogram

<AlgorithmProblem
  title="Largest Rectangle in Histogram"
  difficulty="Hard"
  description={`
<p>Given an array of integers <code>heights</code> representing the histogram's bar height where the width of each bar is <code>1</code>, return the area of the largest rectangle in the histogram.</p>
<h4>Constraints:</h4>
<ul>
  <li>1 &lt;= heights.length &lt;= 10<sup>5</sup></li>
  <li>0 &lt;= heights[i] &lt;= 10<sup>4</sup></li>
</ul>
`}
  examples={[
    {
      input: 'heights = [2,1,5,6,2,3]',
      output: '10',
      explanation: 'The largest rectangle has height 5 and width 2, giving area = 5 × 2 = 10.\nIt spans from index 2 to index 3.'
    },
    {
      input: 'heights = [2,4]',
      output: '4',
      explanation: 'The largest rectangle is the second bar with height 4 and width 1.'
    },
    {
      input: 'heights = [1]',
      output: '1',
      explanation: 'Single bar with height 1 and width 1.'
    }
  ]}
  starterCode={`function largestRectangleArea(heights) {
  // Write your code here

}`}
  solution={`function largestRectangleArea(heights) {
  // Monotonic stack approach: O(n) time, O(n) space
  const stack = []; // Store indices
  let maxArea = 0;

  for (let i = 0; i < heights.length; i++) {
    // While current height is less than stack top
    while (stack.length > 0 && heights[i] < heights[stack[stack.length - 1]]) {
      const heightIndex = stack.pop();
      const height = heights[heightIndex];

      // Width: distance between current and new stack top
      const width = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;
      const area = height * width;
      maxArea = Math.max(maxArea, area);
    }

    stack.push(i);
  }

  // Process remaining bars in stack
  while (stack.length > 0) {
    const heightIndex = stack.pop();
    const height = heights[heightIndex];
    const width = stack.length === 0 ? heights.length : heights.length - stack[stack.length - 1] - 1;
    const area = height * width;
    maxArea = Math.max(maxArea, area);
  }

  return maxArea;
}`}
  testCases={[
    {
      input: [[2, 1, 5, 6, 2, 3]],
      expected: 10,
      description: 'Mixed heights: [2,1,5,6,2,3] → area 10 (5×2)'
    },
    {
      input: [[2, 4]],
      expected: 4,
      description: 'Two bars: [2,4] → area 4 (4×1)'
    },
    {
      input: [[1]],
      expected: 1,
      description: 'Single bar: [1] → area 1'
    },
    {
      input: [[2, 2, 2, 2]],
      expected: 8,
      description: 'Equal heights: [2,2,2,2] → area 8 (2×4)'
    },
    {
      input: [[1, 2, 3, 4, 5]],
      expected: 9,
      description: 'Increasing: [1,2,3,4,5] → area 9 (3×3)'
    },
    {
      input: [[5, 4, 3, 2, 1]],
      expected: 9,
      description: 'Decreasing: [5,4,3,2,1] → area 9 (3×3)'
    }
  ]}
  functionName="largestRectangleArea"
/>

## Solution Explanation

### Approach 1: Brute Force (Not Recommended)

**Time Complexity:** O(n²)
**Space Complexity:** O(1)

For each bar, find the maximum width rectangle using that bar's height:

```javascript
function largestRectangleArea(heights) {
  let maxArea = 0;

  for (let i = 0; i < heights.length; i++) {
    let minHeight = heights[i];

    // Try all widths starting from bar i
    for (let j = i; j < heights.length; j++) {
      minHeight = Math.min(minHeight, heights[j]);
      const area = minHeight * (j - i + 1);
      maxArea = Math.max(maxArea, area);
    }
  }

  return maxArea;
}
```

**Why not use this?**
- O(n²) time complexity too slow for large inputs (up to 10⁵)
- Recalculates minimum height repeatedly
- Doesn't leverage any optimization

### Approach 2: Monotonic Stack (Optimal) ✅

**Time Complexity:** O(n)
**Space Complexity:** O(n)

Use a monotonic increasing stack to efficiently calculate rectangle areas:

```javascript
function largestRectangleArea(heights) {
  const stack = []; // Store indices of bars
  let maxArea = 0;

  for (let i = 0; i < heights.length; i++) {
    // Current bar is shorter than stack top
    // Calculate areas for taller bars
    while (stack.length > 0 &&
           heights[i] < heights[stack[stack.length - 1]]) {
      const heightIndex = stack.pop();
      const height = heights[heightIndex];

      // Calculate width
      // Left boundary: previous bar in stack (or start)
      // Right boundary: current bar (exclusive)
      const width = stack.length === 0
        ? i  // Extends to start
        : i - stack[stack.length - 1] - 1;

      const area = height * width;
      maxArea = Math.max(maxArea, area);
    }

    stack.push(i);
  }

  // Process remaining bars (increasing sequence)
  while (stack.length > 0) {
    const heightIndex = stack.pop();
    const height = heights[heightIndex];
    const width = stack.length === 0
      ? heights.length
      : heights.length - stack[stack.length - 1] - 1;

    const area = height * width;
    maxArea = Math.max(maxArea, area);
  }

  return maxArea;
}
```

**How Monotonic Stack Works:**

```
Input: heights = [2, 1, 5, 6, 2, 3]
         index:    0  1  2  3  4  5

Visualization:
    6 ▓
    5 ▓▓
    4
    3 ▓▓  ▓
    2 ▓▓▓▓▓
    1  ▓▓▓▓▓
      0 1 2 3 4 5

Step-by-step with stack:

i=0: height=2
  stack: [0]

i=1: height=1 < 2
  Pop 0: height=2, width=1 (index 0 to 0), area=2×1=2
  stack: [1]

i=2: height=5 > 1
  stack: [1, 2]

i=3: height=6 > 5
  stack: [1, 2, 3]

i=4: height=2 < 6
  Pop 3: height=6, width=1 (index 3 to 3), area=6×1=6
  Pop 2: height=5, width=2 (index 2 to 3), area=5×2=10 ✅ (max so far)
  height=2 > 1, stop popping
  stack: [1, 4]

i=5: height=3 > 2
  stack: [1, 4, 5]

End of array, process remaining:
  Pop 5: height=3, width=1 (index 5 to 5), area=3×1=3
  Pop 4: height=2, width=4 (index 2 to 5), area=2×4=8
  Pop 1: height=1, width=6 (index 0 to 5), area=1×6=6

Result: maxArea = 10 ✅
```

**Key Insight - Width Calculation:**

When we pop a bar at index `h`:
- **Right boundary**: current index `i` (exclusive)
- **Left boundary**: new stack top (exclusive), or start if stack empty
- **Width**: `i - stack.top() - 1` or `i` if stack empty

```
Example: heights = [1, 5, 6, 2]
                    0  1  2  3

When i=3 (height=2), we pop index 2 (height=6):

Stack after pop: [0, 1]
Left boundary: stack top = 1 (exclusive)
Right boundary: current i = 3 (exclusive)
Width: 3 - 1 - 1 = 1 (only index 2)
Area: 6 × 1 = 6

     ▓
   ▓ ▓
   ▓ ▓ ▓
   ▓ ▓ ▓ ▓
   0 1 2 3
       └─┘ width = 1
```

### Why Monotonic Increasing Stack?

**Monotonic property:**
- Stack maintains indices with increasing heights
- When we see a shorter bar, taller bars can't extend further right
- This is the perfect time to calculate their maximum rectangles

**Key properties:**
1. Each bar pushed once: O(n)
2. Each bar popped once: O(n)
3. Total: O(n) time complexity
4. Stack stores indices not heights (need for width calculation)

### Approach 3: Stack with Sentinel Values

**Time Complexity:** O(n)
**Space Complexity:** O(n)

Add sentinel values to simplify edge cases:

```javascript
function largestRectangleArea(heights) {
  const stack = [-1]; // Sentinel for left boundary
  let maxArea = 0;

  // Add sentinel 0 at the end
  heights.push(0);

  for (let i = 0; i < heights.length; i++) {
    while (stack.length > 1 &&
           heights[i] < heights[stack[stack.length - 1]]) {
      const heightIndex = stack.pop();
      const height = heights[heightIndex];
      const width = i - stack[stack.length - 1] - 1;
      maxArea = Math.max(maxArea, height * width);
    }
    stack.push(i);
  }

  heights.pop(); // Remove sentinel
  return maxArea;
}
```

This approach avoids the final while loop by ensuring all bars are processed.

### Key Insights

1. **Monotonic stack pattern**: Use for "next smaller element" problems
2. **Width calculation is tricky**: Need left and right boundaries
3. **Stack stores indices**: Need indices to calculate width
4. **Process in one pass**: Each bar pushed and popped once
5. **Handle remaining bars**: Don't forget bars still in stack at end

## Common Mistakes

❌ Storing heights instead of indices:
```javascript
stack.push(heights[i]); // Wrong! Can't calculate width
// Should be: stack.push(i)
```

❌ Wrong width calculation:
```javascript
const width = i - stack[stack.length - 1]; // Wrong! Off by one
// Should be: i - stack[stack.length - 1] - 1
// Or if stack empty: i (extends to start)
```

❌ Forgetting to process remaining stack:
```javascript
for (let i = 0; i < heights.length; i++) {
  // ... process bars
}
return maxArea; // Wrong! Stack may have remaining bars
```

❌ Not handling empty stack correctly:
```javascript
while (stack.length > 0 && heights[i] < heights[stack[stack.length - 1]]) {
  const heightIndex = stack.pop();
  const height = heights[heightIndex];
  const width = i - stack[stack.length - 1] - 1; // Wrong! stack might be empty
  maxArea = Math.max(maxArea, height * width);
}
```

✅ Correct approach with proper width calculation:
```javascript
while (stack.length > 0 &&
       heights[i] < heights[stack[stack.length - 1]]) {
  const heightIndex = stack.pop();
  const height = heights[heightIndex];

  // Handle empty stack: rectangle extends to start
  const width = stack.length === 0
    ? i  // Full width from start to current
    : i - stack[stack.length - 1] - 1;  // Between boundaries

  const area = height * width;
  maxArea = Math.max(maxArea, area);
}
```

## Interview Tips

**When discussing this problem:**
1. Recognize it as a **monotonic stack problem**
2. Explain the **key insight**: when we find a shorter bar, we know the max rectangle for taller bars
3. Carefully explain **width calculation** with boundaries
4. Walk through the example `[2,1,5,6,2,3]` step by step
5. Mention handling **remaining bars** in stack

**Key talking points:**
- "This is a classic monotonic stack problem"
- "When we see a shorter bar, taller bars can't extend further right"
- "Stack maintains increasing heights - perfect for finding boundaries"
- "Width calculation: distance between left and right boundaries"
- "Each bar is pushed and popped exactly once - O(n) time"

**Pattern recognition:**
- "Next smaller/greater element" → Monotonic stack
- "Maximum area/rectangle" in array → Consider monotonic stack
- Need to find boundaries → Stack can track them

**Width calculation explanation:**
```
"When we pop a bar, we need to know how far it extends:
- Right boundary: current index (where we found shorter bar)
- Left boundary: previous bar in stack (last bar shorter than popped)
- Width: distance between these boundaries minus 1"
```

**Follow-up questions you might get:**
- **What if all bars are equal?** Stack never pops until end, gives correct width
- **Can you optimize space?** Not really, stack is necessary
- **How to handle maximal rectangle in 2D?** Use this as subroutine
- **What about circular histogram?** Process array twice with modulo
