---
sidebar_position: 4
difficulty: Easy
tags: [linked-lists, deduplication, traversal, amazon, google]
leetcode_url: https://leetcode.com/problems/remove-duplicates-from-sorted-list/
companies: [Amazon, Google, Microsoft, Meta]
pattern: "Linked Lists"
---

import AlgorithmProblem from '@site/src/components/AlgorithmProblem';

# Remove Duplicates from Sorted List

<AlgorithmProblem
  title="Remove Duplicates from Sorted List"
  difficulty="Easy"
  description={`
<p>Given the <code>head</code> of a <strong>sorted</strong> linked list, <em>delete all duplicates</em> such that each unique element appears only <strong>once</strong>. Return the linked list <strong>sorted</strong> as well.</p>
<h4>Constraints:</h4>
<ul>
  <li>The number of nodes in the list is in the range [0, 300]</li>
  <li>-100 ≤ node.val ≤ 100</li>
  <li>The list is guaranteed to be sorted in ascending order</li>
</ul>
`}
  examples={[
    {
      input: 'head = [1,1,2]',
      output: '[1,2]',
      explanation: 'Duplicate 1 is removed'
    },
    {
      input: 'head = [1,1,2,3,3]',
      output: '[1,2,3]',
      explanation: 'All consecutive duplicates are removed'
    },
    {
      input: 'head = [1]',
      output: '[1]',
      explanation: 'Single element list'
    }
  ]}
  starterCode={`class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function deleteDuplicates(head) {
  // TODO: Remove consecutive duplicates
  return head;
}`}
  solution={`class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function deleteDuplicates(head) {
  let curr = head;

  while (curr !== null && curr.next !== null) {
    // If current equals next, skip the duplicate
    if (curr.val === curr.next.val) {
      curr.next = curr.next.next;  // Skip duplicate node
    } else {
      curr = curr.next;  // Move to next node
    }
  }

  return head;
}`}
  testCases={[
    {
      input: [[1, 1, 2]],
      expected: [1, 2],
      description: 'Simple duplicate removal'
    },
    {
      input: [[1, 1, 2, 3, 3]],
      expected: [1, 2, 3],
      description: 'Multiple consecutive duplicates'
    },
    {
      input: [[1]],
      expected: [1],
      description: 'Single element'
    },
    {
      input: [[]],
      expected: [],
      description: 'Empty list'
    },
    {
      input: [[1, 1, 1, 1, 2, 3, 3, 3]],
      expected: [1, 2, 3],
      description: 'Multiple consecutive duplicates of same value'
    },
    {
      input: [[0, 0, 0, 0, 0]],
      expected: [0],
      description: 'All same values'
    }
  ]}
  functionName="deleteDuplicates"
/>

## Solution Explanation

### Approach 1: One Pass (Optimal) ✅

**Time Complexity:** O(n) - single pass through list
**Space Complexity:** O(1) - no extra space needed

Compare each node with its next node. If they're equal, skip the duplicate:

```javascript
function deleteDuplicates(head) {
  let curr = head;

  while (curr !== null && curr.next !== null) {
    if (curr.val === curr.next.val) {
      // Skip the duplicate node
      curr.next = curr.next.next;
    } else {
      // Move to next node
      curr = curr.next;
    }
  }

  return head;
}
```

**How it works:**

```
Initial:  1 → 1 → 2 → 3 → 3 → null
          curr

Step 1: curr.val (1) === curr.next.val (1)?
  YES! Skip: 1 → 2 → 3 → 3 → null
  curr stays at first 1

Step 2: curr.val (1) === curr.next.val (2)?
  NO! Move: curr → 2 → 3 → 3 → null

Step 3: curr.val (2) === curr.next.val (3)?
  NO! Move: curr → 3 → 3 → null

Step 4: curr.val (3) === curr.next.val (3)?
  YES! Skip: 1 → 2 → 3 → null
  curr stays at first 3

Step 5: curr.next === null, loop ends

Result: [1, 2, 3]
```

**Key insight:** When you find a duplicate, skip it (update the link) but DON'T advance the pointer. This handles consecutive duplicates.

### Approach 2: With Dummy Node (Alternative)

**Time Complexity:** O(n)
**Space Complexity:** O(1)

Similar approach but uses a dummy node for consistency:

```javascript
function deleteDuplicates(head) {
  if (!head) return null;

  let curr = head;

  while (curr && curr.next) {
    if (curr.val === curr.next.val) {
      curr.next = curr.next.next;  // Skip duplicate
    } else {
      curr = curr.next;  // Advance pointer
    }
  }

  return head;
}
```

**Advantage:** Handles null more gracefully
**Same complexity:** Still O(n) time, O(1) space

### Approach 3: Recursive

**Time Complexity:** O(n)
**Space Complexity:** O(n) - recursion stack

Recursively process the list:

```javascript
function deleteDuplicates(head) {
  // Base case
  if (!head || !head.next) return head;

  // If current equals next, skip current and recurse
  if (head.val === head.next.val) {
    return deleteDuplicates(head.next);
  }

  // Otherwise, process next part recursively
  head.next = deleteDuplicates(head.next);
  return head;
}
```

**Advantage:** Elegant code
**Disadvantage:** Uses O(n) space for recursion stack

## Comparison of Approaches

| Approach | Time | Space | Simplicity | Best For |
|----------|------|-------|-----------|----------|
| One Pass | O(n) | O(1) | Simple | **Recommended** |
| With Dummy | O(n) | O(1) | Clear | Alternative |
| Recursive | O(n) | O(n) | Elegant | Follow-up |

## Common Mistakes

❌ **Advancing the pointer when finding a duplicate:**
```javascript
if (curr.val === curr.next.val) {
  curr.next = curr.next.next;
  curr = curr.next;  // ERROR! Skips checking multiple duplicates
}
```

✅ **Don't advance when skipping duplicate:**
```javascript
if (curr.val === curr.next.val) {
  curr.next = curr.next.next;
  // DON'T advance curr - check this node again
}
```

---

❌ **Not checking if curr.next exists:**
```javascript
while (curr !== null) {
  if (curr.val === curr.next.val) {  // ERROR: curr.next might be null!
    curr.next = curr.next.next;
  }
}
```

✅ **Check both curr and curr.next:**
```javascript
while (curr !== null && curr.next !== null) {
  if (curr.val === curr.next.val) {
    curr.next = curr.next.next;
  } else {
    curr = curr.next;
  }
}
```

---

❌ **Modifying the list incorrectly:**
```javascript
// This removes the reference but doesn't affect the list
let temp = curr.next.next;
curr.next = temp;
// This is fine, but can be written more concisely
```

✅ **Direct assignment is cleaner:**
```javascript
curr.next = curr.next.next;  // Direct and clear
```

---

❌ **Forgetting to handle empty list:**
```javascript
function deleteDuplicates(head) {
  let curr = head;
  // What if head is null?
  while (curr.next !== null) {  // ERROR: curr is null!
    // ...
  }
}
```

✅ **Always check for null:**
```javascript
function deleteDuplicates(head) {
  if (!head) return null;
  let curr = head;
  while (curr !== null && curr.next !== null) {
    // ...
  }
  return head;
}
```

## Interview Tips

**What to mention:**
1. **Single pass:** This is O(n) time, single pass
2. **No extra space:** We only rearrange pointers
3. **Sorted list:** Takes advantage of sorted property
4. **Why we don't advance sometimes:** To handle consecutive duplicates

**Follow-up questions:**

**Q: What if we need to remove ALL occurrences of duplicates (not just consecutive)?**
A: Different problem - "Remove All Duplicates in Sorted List II"
```javascript
// Example: [1,2,2,2,3] → [1,3]
// Removes ALL 2s, not just keeping one
```

**Q: What if the list is not sorted?**
A: Use a Set to track seen values, more complex logic needed.

**Q: Can you do it recursively?**
A: Yes, but uses O(n) space for call stack instead of O(1).

**Q: What about memory efficiency with large lists?**
A: This approach is optimal - O(n) time, O(1) space is best possible.

## Edge Cases

```javascript
// Empty list
[] → []

// Single element
[1] → [1]

// No duplicates
[1, 2, 3, 4, 5] → [1, 2, 3, 4, 5]

// All same elements
[1, 1, 1, 1, 1] → [1]

// Duplicates at start
[1, 1, 1, 2, 3] → [1, 2, 3]

// Duplicates at end
[1, 2, 3, 3, 3] → [1, 2, 3]

// Multiple duplicate groups
[1, 1, 2, 2, 3, 3] → [1, 2, 3]

// With negative numbers
[-1, -1, 0, 0, 1] → [-1, 0, 1]
```

## Why This Works on Sorted Lists

The algorithm relies on the list being sorted. For a sorted list, all duplicates are consecutive. So:

1. We can check each node against the next
2. If they match, we skip the next node
3. If they don't match, we move forward
4. This removes all consecutive duplicates in one pass

For unsorted lists, you'd need different approaches (hash set, multiple passes, etc.).

## Related Problems

- **Remove All Duplicates in Sorted List II** (Medium) - Remove ALL duplicate occurrences
- **Remove Duplicates from Unsorted List** (Medium) - List is not sorted
- **Remove Nth Node From End** (Medium) - Different deletion operation
- **Remove Linked List Elements** (Easy) - Remove elements with value
