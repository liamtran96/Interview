---
sidebar_position: 10
difficulty: Hard
tags: [dynamic-programming, string, two-strings]
leetcode_url: https://leetcode.com/problems/edit-distance/
companies: [Amazon, Google, Microsoft, Meta, Apple]
pattern: "Dynamic Programming"
---

import AlgorithmProblem from '@site/src/components/AlgorithmProblem';

# Edit Distance (Levenshtein Distance)

<AlgorithmProblem
  title="Edit Distance"
  difficulty="Hard"
  description={`
<p>Given two strings <code>word1</code> and <code>word2</code>, return <em>the minimum number of operations</em> required to convert <code>word1</code> to <code>word2</code>.</p>
<p>You have the following three operations permitted on a word:</p>
<ul>
  <li>Insert a character</li>
  <li>Delete a character</li>
  <li>Replace a character</li>
</ul>
<h4>Constraints:</h4>
<ul>
  <li>0 &le; word1.length, word2.length &le; 500</li>
  <li>word1 and word2 consist of lowercase English letters</li>
</ul>
`}
  examples={[
    {
      input: 'word1 = "horse", word2 = "ros"',
      output: '3',
      explanation: 'horse → rorse (replace h with r) → rose (delete o) → ros (delete e)'
    },
    {
      input: 'word1 = "intention", word2 = "execution"',
      output: '5',
      explanation: 'intention → enention (replace i with e) → exention (replace n with x) → exection (replace n with c) → execution (insert u)'
    },
    {
      input: 'word1 = "abc", word2 = "abc"',
      output: '0',
      explanation: 'Strings are identical'
    }
  ]}
  starterCode={`function minDistance(word1, word2) {
  // Write your code here

}`}
  solution={`function minDistance(word1, word2) {
  // 2D DP - Tabulation: O(m*n) time, O(m*n) space
  const m = word1.length;
  const n = word2.length;

  // dp[i][j] = min operations to convert word1[0..i-1] to word2[0..j-1]
  const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));

  // Base cases: converting from/to empty string
  for (let i = 0; i <= m; i++) dp[i][0] = i; // Delete all
  for (let j = 0; j <= n; j++) dp[0][j] = j; // Insert all

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (word1[i - 1] === word2[j - 1]) {
        // Characters match: no operation needed
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        // Characters don't match: try all three operations
        dp[i][j] = 1 + Math.min(
          dp[i - 1][j],     // Delete from word1
          dp[i][j - 1],     // Insert into word1
          dp[i - 1][j - 1]  // Replace in word1
        );
      }
    }
  }

  return dp[m][n];
}`}
  testCases={[
    {
      input: ["horse", "ros"],
      expected: 3,
      description: 'horse → ros requires 3 operations'
    },
    {
      input: ["intention", "execution"],
      expected: 5,
      description: 'intention → execution requires 5 operations'
    },
    {
      input: ["abc", "abc"],
      expected: 0,
      description: 'Identical strings'
    },
    {
      input: ["a", "b"],
      expected: 1,
      description: 'Single character replacement'
    },
    {
      input: ["", "abc"],
      expected: 3,
      description: 'Insert all characters'
    },
    {
      input: ["abc", ""],
      expected: 3,
      description: 'Delete all characters'
    }
  ]}
  functionName="minDistance"
/>

## Solution Explanation

### Approach 1: Brute Force Recursion

**Time Complexity:** O(3<sup>m + n</sup>) exponential
**Space Complexity:** O(m + n) recursive stack

Try all possible operations:

```javascript
function minDistance(word1, word2) {
  function helper(i, j) {
    // Base cases
    if (i === 0) return j; // Insert remaining chars from word2
    if (j === 0) return i; // Delete remaining chars from word1

    // If characters match, move both pointers
    if (word1[i - 1] === word2[j - 1]) {
      return helper(i - 1, j - 1);
    }

    // Try all three operations
    const deleteOp = helper(i - 1, j);      // Delete from word1
    const insertOp = helper(i, j - 1);      // Insert into word1
    const replaceOp = helper(i - 1, j - 1); // Replace in word1

    return 1 + Math.min(deleteOp, insertOp, replaceOp);
  }

  return helper(word1.length, word2.length);
}

// Example: word1="ab", word2="a"
//                helper(2, 1)
//         /          |          \
//    del:h(1,1)  ins:h(2,0)  rep:h(1,0)
//       (0)        (2)         (1)
//     min(0+1)=1   2           1
// min(1, 2, 1) = 1 ✓
```

**Why slow?** Many overlapping subproblems.

### Approach 2: Memoization (Better)

**Time Complexity:** O(m × n)
**Space Complexity:** O(m × n)

Cache intermediate results:

```javascript
function minDistance(word1, word2) {
  const memo = {};

  function helper(i, j) {
    if (i === 0) return j;
    if (j === 0) return i;

    const key = `${i},${j}`;
    if (key in memo) return memo[key];

    if (word1[i - 1] === word2[j - 1]) {
      memo[key] = helper(i - 1, j - 1);
    } else {
      memo[key] = 1 + Math.min(
        helper(i - 1, j),
        helper(i, j - 1),
        helper(i - 1, j - 1)
      );
    }

    return memo[key];
  }

  return helper(word1.length, word2.length);
}
```

### Approach 3: DP Tabulation (Optimal) ✅

**Time Complexity:** O(m × n)
**Space Complexity:** O(m × n)

Build table bottom-up:

```javascript
function minDistance(word1, word2) {
  const m = word1.length;
  const n = word2.length;

  // dp[i][j] = min operations to convert word1[0..i-1] to word2[0..j-1]
  const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));

  // Base cases
  for (let i = 0; i <= m; i++) dp[i][0] = i; // Delete all
  for (let j = 0; j <= n; j++) dp[0][j] = j; // Insert all

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (word1[i - 1] === word2[j - 1]) {
        // No operation needed
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        // Try all three operations
        dp[i][j] = 1 + Math.min(
          dp[i - 1][j],     // Delete
          dp[i][j - 1],     // Insert
          dp[i - 1][j - 1]  // Replace
        );
      }
    }
  }

  return dp[m][n];
}

// Trace: word1="horse", word2="ros"
//        ''  r  o  s
//    ''  0   1  2  3
//    h   1   1  2  3
//    o   2   2  1  2
//    r   3   2  2  2
//    s   4   3  3  2
//    e   5   4  4  3
```

## DP Recurrence Relation

```
dp[i][j] = min operations to convert word1[0..i-1] to word2[0..j-1]

If word1[i-1] === word2[j-1]:
  dp[i][j] = dp[i-1][j-1]
  (no operation needed, characters match)

Otherwise:
  dp[i][j] = 1 + min(
    dp[i-1][j],     (delete from word1)
    dp[i][j-1],     (insert into word1)
    dp[i-1][j-1]    (replace in word1)
  )

Base cases:
  dp[i][0] = i (delete i characters)
  dp[0][j] = j (insert j characters)
```

## Understanding the Three Operations

**Delete from word1:**
- Convert word1[0..i-2] to word2[0..j-1]
- Then delete word1[i-1]
- Cost: dp[i-1][j] + 1

**Insert into word1:**
- Convert word1[0..i-1] to word2[0..j-2]
- Then insert word2[j-1]
- Cost: dp[i][j-1] + 1

**Replace in word1:**
- Convert word1[0..i-2] to word2[0..j-2]
- Then replace word1[i-1] with word2[j-1]
- Cost: dp[i-1][j-1] + 1

**Choose operation with minimum cost.**

## Visualization: Building the DP Table

```
word1 = "horse"
word2 = "ros"

       ''  r  o  s
    '' 0   1  2  3   (insert r, ro, ros)
    h  1   1  2  3   (delete h, then handle ro/ros)
    o  2   2  1  2   (delete ho, or match o)
    r  3   2  2  2   (delete hor, or match r and o)
    s  4   3  3  2   (delete hors, or match s)
    e  5   4  4  3   (delete horse, or insert e)

Key cells:
- (1,1): h vs r, no match → 1 + min(dp[0][1]=1, dp[1][0]=1, dp[0][0]=0) = 1
- (2,2): o vs o, MATCH → dp[1][1] = 1
- (3,1): r vs r, MATCH → dp[2][0] = 2
- (5,3): e vs s, no match → 1 + min(dp[4][3]=2, dp[5][2]=4, dp[4][2]=3) = 3
```

## Common Mistakes

❌ **Wrong operation costs:**
```javascript
// Wrong - all operations don't have same cost
if (operation1) return cost1;
if (operation2) return cost2;

// Correct - all operations cost 1, choose minimum
dp[i][j] = 1 + Math.min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]);
```

❌ **Not initializing base cases:**
```javascript
// Wrong - base cases not set
const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));

// Correct - initialize edges
for (let i = 0; i <= m; i++) dp[i][0] = i;
for (let j = 0; j <= n; j++) dp[0][j] = j;
```

❌ **Forgetting to check character match:**
```javascript
// Wrong - always applies operations
dp[i][j] = 1 + Math.min(
  dp[i-1][j],
  dp[i][j-1],
  dp[i-1][j-1]
);

// Correct - check if characters match
if (word1[i-1] === word2[j-1]) {
  dp[i][j] = dp[i-1][j-1];
} else {
  dp[i][j] = 1 + Math.min(...);
}
```

❌ **Off-by-one errors in indexing:**
```javascript
// Wrong - using dp[i] instead of dp[i-1]
if (word1[i] === word2[j]) {  // Should be i-1 and j-1

// Correct
if (word1[i-1] === word2[j-1]) {
```

✅ **Correct solution:**
```javascript
function minDistance(word1, word2) {
  const m = word1.length;
  const n = word2.length;

  const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));

  for (let i = 0; i <= m; i++) dp[i][0] = i;
  for (let j = 0; j <= n; j++) dp[0][j] = j;

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (word1[i - 1] === word2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = 1 + Math.min(
          dp[i - 1][j],
          dp[i][j - 1],
          dp[i - 1][j - 1]
        );
      }
    }
  }

  return dp[m][n];
}
```

## Interview Tips

**When discussing:**
1. Clarify: "Three operations: insert, delete, replace"
2. State: "`dp[i][j]` = min operations for word1[0..i-1] to word2[0..j-1]"
3. Base: "Convert to/from empty string requires n/m operations"
4. Recurrence: "If match: no op. Else: 1 + min of three options"
5. Complexity: "O(m × n) time and space"

**Key talking points:**
- "This is the classic Levenshtein distance problem"
- "Similar to LCS but with three operations instead of two paths"
- "Base cases are crucial: edges represent adding/removing all chars"
- "Choose the minimum-cost operation at each step"
- "Can optimize space to O(n) with rolling array"

**Follow-up questions:**

**Q: Return the actual sequence of operations?**
A: Backtrack from dp[m][n], recording operations used.

**Q: Operations have different costs?**
A: Modify the `1 +` to match the operation cost.

**Q: Optimize space to O(n)?**
A: Use rolling array, keep only previous and current rows.

**Q: Case-insensitive comparison?**
A: Convert to lowercase before processing.

## Edge Cases

```javascript
minDistance("", "") → 0                    // Both empty
minDistance("a", "") → 1                   // Delete one
minDistance("", "b") → 1                   // Insert one
minDistance("a", "b") → 1                  // Replace
minDistance("abc", "abc") → 0              // Identical
minDistance("abc", "xyz") → 3              // Replace all
minDistance("abc", "abcd") → 1             // Insert one
```

## Related Problems

- **Longest Common Subsequence** (Medium) - Similar 2D DP
- **Minimum ASCII Delete Sum for Two Strings** (Medium) - Weighted edit distance
- **Distinct Subsequences** (Hard) - Different recurrence
- **Regular Expression Matching** (Hard) - Pattern matching DP
- **Wildcard Matching** (Hard) - Similar string matching
