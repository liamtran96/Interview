---
sidebar_position: 5
difficulty: Easy
tags: [dynamic-programming, array, greedy, tracking]
leetcode_url: https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
companies: [Amazon, Meta, Google, Apple, Microsoft]
pattern: "Dynamic Programming"
---

import AlgorithmProblem from '@site/src/components/AlgorithmProblem';

# Best Time to Buy and Sell Stock

<AlgorithmProblem
  title="Best Time to Buy and Sell Stock"
  difficulty="Easy"
  description={`
<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the i<sup>th</sup> day.</p>
<p>You want to maximize your profit by choosing a <strong>single day</strong> to buy one stock and a <strong>different day</strong> to sell that stock.</p>
<p>Return the <em>maximum profit</em> you can achieve from this transaction. If you cannot make any profit, return <code>0</code>.</p>
<h4>Constraints:</h4>
<ul>
  <li>1 &le; prices.length &le; 10<sup>5</sup></li>
  <li>0 &le; prices[i] &le; 10<sup>4</sup></li>
</ul>
<h4>Constraint:</h4>
<p>You must buy before you sell.</p>
`}
  examples={[
    {
      input: 'prices = [7,1,5,3,6,4]',
      output: '5',
      explanation: 'Buy at price 1, sell at price 6. Profit = 6 - 1 = 5'
    },
    {
      input: 'prices = [7,6,4,3,1]',
      output: '0',
      explanation: 'No profit possible in descending prices. Return 0'
    },
    {
      input: 'prices = [2,4,1,7,5,11]',
      output: '10',
      explanation: 'Buy at price 1, sell at price 11. Profit = 11 - 1 = 10'
    }
  ]}
  starterCode={`function maxProfit(prices) {
  // Write your code here

}`}
  solution={`function maxProfit(prices) {
  // Track minimum price and maximum profit: O(n) time, O(1) space
  let minPrice = prices[0];
  let maxProfit = 0;

  for (let i = 1; i < prices.length; i++) {
    // Profit if we sell at current price
    const potentialProfit = prices[i] - minPrice;

    // Update maximum profit
    maxProfit = Math.max(maxProfit, potentialProfit);

    // Update minimum price seen so far
    minPrice = Math.min(minPrice, prices[i]);
  }

  return maxProfit;
}`}
  testCases={[
    {
      input: [[7, 1, 5, 3, 6, 4]],
      expected: 5,
      description: 'Buy at 1, sell at 6'
    },
    {
      input: [[7, 6, 4, 3, 1]],
      expected: 0,
      description: 'Descending prices: no profit'
    },
    {
      input: [[2, 4, 1, 7, 5, 11]],
      expected: 10,
      description: 'Buy at 1, sell at 11'
    },
    {
      input: [[1]],
      expected: 0,
      description: 'Single price: no transaction'
    },
    {
      input: [[2, 4, 1]],
      expected: 2,
      description: 'Buy at 2, sell at 4'
    },
    {
      input: [[3, 2, 6, 5, 0, 3]],
      expected: 4,
      description: 'Buy at 2, sell at 6'
    }
  ]}
  functionName="maxProfit"
/>

## Solution Explanation

### Approach 1: Brute Force

**Time Complexity:** O(n²)
**Space Complexity:** O(1)

Check all buy-sell pairs:

```javascript
function maxProfit(prices) {
  let maxProfit = 0;

  // Try all buy days
  for (let i = 0; i < prices.length - 1; i++) {
    // Try all sell days after buy day
    for (let j = i + 1; j < prices.length; j++) {
      const profit = prices[j] - prices[i];
      maxProfit = Math.max(maxProfit, profit);
    }
  }

  return maxProfit;
}

// Example: prices = [7, 1, 5, 3, 6, 4]
// i=0 (buy at 7):
//   j=1: profit = 1 - 7 = -6
//   j=2: profit = 5 - 7 = -2
//   j=3: profit = 3 - 7 = -4
//   j=4: profit = 6 - 7 = -1
//   j=5: profit = 4 - 7 = -3
// i=1 (buy at 1):
//   j=2: profit = 5 - 1 = 4
//   j=3: profit = 3 - 1 = 2
//   j=4: profit = 6 - 1 = 5 ✓
//   j=5: profit = 4 - 1 = 3
// i=2 (buy at 5):
//   j=3: profit = 3 - 5 = -2
//   j=4: profit = 6 - 5 = 1
//   j=5: profit = 4 - 5 = -1
// i=3 (buy at 3):
//   j=4: profit = 6 - 3 = 3
//   j=5: profit = 4 - 3 = 1
// i=4 (buy at 6):
//   j=5: profit = 4 - 6 = -2
// Max profit: 5
```

**Why avoid?** Too many comparisons for large arrays.

### Approach 2: One Pass with Tracking (Optimal) ✅

**Time Complexity:** O(n)
**Space Complexity:** O(1)

Track minimum price and maximum profit in one pass:

```javascript
function maxProfit(prices) {
  let minPrice = prices[0];  // Minimum price seen so far (best buy)
  let maxProfit = 0;         // Maximum profit seen so far

  for (let i = 1; i < prices.length; i++) {
    // If we sell at current price, what's the profit?
    const potentialProfit = prices[i] - minPrice;

    // Update maximum profit
    maxProfit = Math.max(maxProfit, potentialProfit);

    // Update minimum price (best buy point so far)
    minPrice = Math.min(minPrice, prices[i]);
  }

  return maxProfit;
}

// Trace: prices = [7, 1, 5, 3, 6, 4]
// i=1: profit = 1 - 7 = -6, maxProfit = 0, minPrice = 1
// i=2: profit = 5 - 1 = 4, maxProfit = 4, minPrice = 1
// i=3: profit = 3 - 1 = 2, maxProfit = 4, minPrice = 1
// i=4: profit = 6 - 1 = 5, maxProfit = 5, minPrice = 1 ✓
// i=5: profit = 4 - 1 = 3, maxProfit = 5, minPrice = 1
// Result: 5
```

**How it works:**

The key insight: **Profit at day i = prices[i] - lowest_price_before_i**

By tracking:
1. **minPrice**: Best buying opportunity so far
2. **maxProfit**: Best profit we can achieve

We ensure the buy happens before the sell.

### DP Perspective (Cleaner Understanding)

We can think of this as DP where:
- **State:** Maximum profit we can achieve by selling at day i
- **Transition:** For each day i, profit = prices[i] - min(prices[0...i-1])

```javascript
function maxProfit(prices) {
  const dp = new Array(prices.length).fill(0);

  let minPrice = prices[0];

  for (let i = 1; i < prices.length; i++) {
    // Max profit if we sell at day i
    dp[i] = Math.max(0, prices[i] - minPrice);

    // Update minimum price
    minPrice = Math.min(minPrice, prices[i]);
  }

  return Math.max(...dp);
}

// This is essentially the same as the optimized version
// But dp array makes the DP state explicit
```

## Key Insights

**The optimal solution's elegance:**

```
For each price:
├─ Calculate profit if we sell here: price - min_price_so_far
├─ Update maximum profit
└─ Update minimum price

This guarantees:
- Buy happens before sell (minPrice is from past)
- Sell is at current position (prices[i])
- We find maximum profit
```

**Why greedy works here:**

To maximize profit, we want:
1. Smallest price to buy (earliest minimum)
2. Largest price to sell (any price greater than the minimum)

By tracking minimum as we go, we always have the best buy option, and we check all sell options.

## Comparison: Brute Force vs Optimal

| Approach | Time | Space | Method |
|----------|------|-------|--------|
| Brute Force | O(n²) | O(1) | Check all pairs |
| **Optimal** | **O(n)** | **O(1)** | **Track min & max profit** |

## Common Mistakes

❌ **Not initializing maxProfit to 0:**
```javascript
// Wrong - all negative profits would return minimum instead of 0
let maxProfit = Number.NEGATIVE_INFINITY;

// Correct - return 0 if no profit possible
let maxProfit = 0;
```

❌ **Updating minPrice before calculating profit:**
```javascript
// Wrong - using current price as minimum
for (let i = 1; i < prices.length; i++) {
  minPrice = Math.min(minPrice, prices[i]);  // Do this AFTER profit calc
  const profit = prices[i] - minPrice;       // Wrong order!
}

// Correct - calculate profit first, then update minPrice
for (let i = 1; i < prices.length; i++) {
  const profit = prices[i] - minPrice;
  maxProfit = Math.max(maxProfit, profit);
  minPrice = Math.min(minPrice, prices[i]);
}
```

❌ **Allowing sell on same day as buy:**
```javascript
// Wrong - no validation
for (let i = 0; i < prices.length; i++) {
  for (let j = 0; j <= i; j++) {  // Wrong: j should start at i+1
    // ...
  }
}

// Correct - buy before sell
for (let i = 0; i < prices.length - 1; i++) {
  for (let j = i + 1; j < prices.length; j++) {
    // ...
  }
}
```

✅ **Correct solution:**
```javascript
function maxProfit(prices) {
  let minPrice = prices[0];
  let maxProfit = 0;

  for (let i = 1; i < prices.length; i++) {
    const potentialProfit = prices[i] - minPrice;
    maxProfit = Math.max(maxProfit, potentialProfit);
    minPrice = Math.min(minPrice, prices[i]);
  }

  return maxProfit;
}
```

## Interview Tips

**When discussing:**
1. State: "We need to track minimum price seen so far"
2. Decision: "For each day, calculate profit if we sell today"
3. Track: "Keep track of both minimum price and maximum profit"
4. Constraint: "Buy must happen before sell"
5. Optimize: "Single pass with O(1) space"

**Key talking points:**
- "This is a one-pass greedy solution"
- "Key insight: profit = current_price - minimum_price_so_far"
- "We don't need to store all previous prices, just the minimum"
- "Buy constraint is naturally satisfied since minPrice is from the past"

**Follow-up questions:**

**Q: Return the days to buy and sell, not just profit?**
A: Track indices when updating minPrice and maxProfit.

**Q: What if you can make multiple transactions?**
A: Different problem - sum profits of all uptrends (greedy).

**Q: What if you must buy and sell but transaction cost exists?**
A: Subtract fee from profit: `profit = prices[i] - minPrice - fee`

**Q: What if you have a cooldown day after selling?**
A: Use DP with states: bought, sold, cooldown.

**Q: What if you can hold multiple stocks?**
A: More complex, requires different DP state.

## Edge Cases

```javascript
maxProfit([1]) → 0              // Single price
maxProfit([1, 2]) → 1           // Two prices
maxProfit([7, 6, 4, 3, 1]) → 0  // Descending
maxProfit([1, 2, 3, 4, 5]) → 4  // Ascending (buy first, sell last)
maxProfit([2, 4, 1]) → 2        // Buy at 2, sell at 4
maxProfit([3, 2, 6, 5, 0, 3]) → 4 // Buy at 2, sell at 6
```

## Related Problems

- **Best Time to Buy and Sell Stock II** (Medium) - Multiple transactions allowed
- **Best Time to Buy and Sell Stock III** (Hard) - At most 2 transactions
- **Best Time to Buy and Sell Stock IV** (Hard) - At most k transactions
- **Best Time to Buy and Sell Stock with Cooldown** (Medium) - Cooldown after sell
- **Best Time to Buy and Sell Stock with Transaction Fee** (Medium) - Fee per transaction
