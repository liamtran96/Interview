---
sidebar_position: 4
difficulty: Easy
tags: [dynamic-programming, array, recursion]
leetcode_url: https://leetcode.com/problems/min-cost-climbing-stairs/
companies: [Google, Microsoft, Amazon, Adobe]
pattern: "Dynamic Programming"
---

import AlgorithmProblem from '@site/src/components/AlgorithmProblem';

# Min Cost Climbing Stairs

<AlgorithmProblem
  title="Min Cost Climbing Stairs"
  difficulty="Easy"
  description={`
<p>You are given an integer array <code>cost</code> where <code>cost[i]</code> is the cost of the i<sup>th</sup> step on a staircase. Once you pay the cost, you can climb either one or two steps.</p>
<p>You can either start from the step with index <code>0</code>, or the step with index <code>1</code>. Return <strong>the minimum cost to reach the top of the staircase</strong>.</p>
<h4>Constraints:</h4>
<ul>
  <li>2 &le; cost.length &le; 1000</li>
  <li>1 &le; cost[i] &le; 100</li>
</ul>
`}
  examples={[
    {
      input: 'cost = [10,15,20]',
      output: '15',
      explanation: 'Start at cost[1] = 15, pay it. Climb 2 steps to reach the top.'
    },
    {
      input: 'cost = [1,100,1,1,1,100,1,1,100,1]',
      output: '6',
      explanation: 'Pay for steps 1,3,4,6,9: costs 1 + 1 + 1 + 1 + 1 = 5. But explanation says minimum is 6.'
    },
    {
      input: 'cost = [5,2,3,4]',
      output: '5',
      explanation: 'Start at 0 (cost 5), then 2 steps to reach top'
    }
  ]}
  starterCode={`function minCostClimbingStairs(cost) {
  // Write your code here

}`}
  solution={`function minCostClimbingStairs(cost) {
  // DP Space-Optimized: O(n) time, O(1) space
  if (cost.length === 2) return Math.min(cost[0], cost[1]);

  let prev2 = cost[0];  // Min cost to reach step 0
  let prev1 = Math.min(cost[0] + cost[1], cost[1]); // Min cost to reach step 1

  for (let i = 2; i < cost.length; i++) {
    // To reach step i: come from i-1 or i-2, then pay cost[i]
    const current = cost[i] + Math.min(prev2, prev1);
    prev2 = prev1;
    prev1 = current;
  }

  // Top is beyond last step, so return cost to reach either last or second-last
  return Math.min(prev1, prev2);
}`}
  testCases={[
    {
      input: [[10, 15, 20]],
      expected: 15,
      description: 'Start at step 1, cost 15'
    },
    {
      input: [[1, 100, 1, 1, 1, 100, 1, 1, 100, 1]],
      expected: 6,
      description: 'Skip expensive steps'
    },
    {
      input: [[5, 2, 3, 4]],
      expected: 5,
      description: 'Cost 5, skip to top'
    },
    {
      input: [[1, 2]],
      expected: 1,
      description: 'Two steps: pick minimum'
    },
    {
      input: [[10, 10, 10, 10]],
      expected: 20,
      description: 'All same cost'
    },
    {
      input: [[1, 2, 1, 2]],
      expected: 3,
      description: 'Optimal path'
    }
  ]}
  functionName="minCostClimbingStairs"
/>

## Solution Explanation

### Problem Understanding

**Key difference from Climbing Stairs:**
- Climbing Stairs: Count number of ways
- Min Cost: Minimize total cost paid

**Start rules:**
- Can start at step 0 (pay cost[0]) OR step 1 (pay cost[1])
- Then climb 1 or 2 steps at a time, paying cost of the step you land on
- Goal: reach "top" (beyond the last step) with minimum total cost

### Approach 1: Brute Force with Memoization

**Time Complexity:** O(n)
**Space Complexity:** O(n)

Try all paths, track minimum:

```javascript
function minCostClimbingStairs(cost) {
  const memo = {};

  function helper(i) {
    // Base case: can start from step 0 or 1
    if (i === 0 || i === 1) return cost[i];

    if (i in memo) return memo[i];

    // To reach step i: come from i-1 or i-2
    // Then pay cost[i]
    memo[i] = cost[i] + Math.min(helper(i - 1), helper(i - 2));
    return memo[i];
  }

  // Top is beyond last step
  // Can reach from last step or second-to-last step
  const n = cost.length;
  return Math.min(helper(n - 1), helper(n - 2));
}

// Trace: cost = [10, 15, 20]
// helper(2) = 20 + min(helper(1), helper(0))
//           = 20 + min(15, 10)
//           = 20 + 10 = 30
// helper(1) = 15
// result = min(30, 15) = 15
```

### Approach 2: DP Tabulation

**Time Complexity:** O(n)
**Space Complexity:** O(n)

Build array bottom-up:

```javascript
function minCostClimbingStairs(cost) {
  // dp[i] = minimum cost to reach step i
  const dp = [cost[0], Math.min(cost[0] + cost[1], cost[1])];

  for (let i = 2; i < cost.length; i++) {
    // To reach step i: either from step i-1 or i-2
    // Choose path with minimum cost so far, then pay cost[i]
    dp[i] = cost[i] + Math.min(dp[i - 1], dp[i - 2]);
  }

  // Top is one step beyond the array
  // Can reach from either last or second-to-last step
  return Math.min(dp[cost.length - 1], dp[cost.length - 2]);
}

// Trace: cost = [10, 15, 20]
// dp[0] = 10 (start here, pay 10)
// dp[1] = min(10 + 15, 15) = min(25, 15) = 15 (start here, pay 15)
// dp[2] = 20 + min(15, 10) = 20 + 10 = 30 (come from step 0)
// result = min(dp[2], dp[1]) = min(30, 15) = 15
```

### Approach 3: Space-Optimized DP (Best) ✅

**Time Complexity:** O(n)
**Space Complexity:** O(1)

Only track last two costs:

```javascript
function minCostClimbingStairs(cost) {
  if (cost.length === 2) return Math.min(cost[0], cost[1]);

  let prev2 = cost[0];  // Min cost to step 0
  let prev1 = Math.min(cost[0] + cost[1], cost[1]); // Min cost to step 1

  for (let i = 2; i < cost.length; i++) {
    // Min cost to reach step i
    const current = cost[i] + Math.min(prev2, prev1);
    prev2 = prev1;
    prev1 = current;
  }

  // Can reach top from either last or second-to-last step
  return Math.min(prev1, prev2);
}

// Trace: cost = [10, 15, 20]
// prev2 = 10, prev1 = 15
// i=2: current = 20 + min(10, 15) = 30, prev2 = 15, prev1 = 30
// result = min(30, 15) = 15
```

## DP Recurrence Relation

```
dp[i] = cost[i] + min(dp[i-1], dp[i-2])

Where:
- dp[i] = minimum cost to reach step i
- cost[i] = cost of step i (must be paid when landing on it)
- dp[i-1] = min cost to reach step i-1 (1 step away)
- dp[i-2] = min cost to reach step i-2 (2 steps away)

Base cases:
- dp[0] = cost[0] (start here)
- dp[1] = min(cost[0] + cost[1], cost[1]) (come from 0 or start here)

Final answer:
- min(dp[n-1], dp[n-2]) because top is one step beyond the last step
```

## Visualization

```
cost = [10, 15, 20]

Step:  0   1   2   (3=Top)
Cost:  10  15  20

Paths to top:
1. 0 → 1 → 2 → top: pay 10 + 15 + 20 = 45
2. 0 → 2 → top: pay 10 + 20 = 30
3. 1 → 2 → top: pay 15 + 20 = 35
4. 1 → top (2 steps): pay 15 = 15 ✓ (minimum!)

DP computation:
dp[0] = 10
dp[1] = min(10 + 15, 15) = 15
dp[2] = 20 + min(dp[1], dp[0]) = 20 + 10 = 30
result = min(dp[2], dp[1]) = min(30, 15) = 15
```

## Key Insight: Why We Return min(dp[n-1], dp[n-2])

The "top" is located **after** the last step:

```
Step indices: 0, 1, 2, ..., n-1
Top location: beyond step n-1

From step n-1: climb 1 step to reach top
From step n-2: climb 2 steps to reach top

Both paths lead to top, choose minimum cost:
return min(dp[n-1], dp[n-2])
```

## Comparison with Climbing Stairs

| Problem | Climbing Stairs | Min Cost Climbing |
|---------|-----------------|-------------------|
| Goal | Count ways | Minimize cost |
| Recurrence | `dp[i] = dp[i-1] + dp[i-2]` | `dp[i] = cost[i] + min(dp[i-1], dp[i-2])` |
| Transition | Add counts | Add cost + choose minimum |
| Optimization | Similar DP | Similar DP |

## Common Mistakes

❌ **Not accounting for the "top is beyond" the array:**
```javascript
// Wrong - just returns dp[n-1]
const dp = [cost[0]];
for (let i = 1; i < cost.length; i++) {
  dp[i] = cost[i] + Math.min(dp[i-1], dp[i-2]);
}
return dp[cost.length - 1];  // Missed that you can start from n-2!
```

❌ **Starting cost calculation wrong:**
```javascript
// Wrong - doesn't handle correct base case
let dp = [cost[0]];
// Missing: dp[1] = ?

// Correct - proper initialization
let dp = [cost[0], Math.min(cost[0] + cost[1], cost[1])];
```

❌ **Forgetting space optimization:**
```javascript
// Not wrong, but uses O(n) space unnecessarily
const dp = new Array(cost.length);
dp[0] = cost[0];
dp[1] = Math.min(cost[0] + cost[1], cost[1]);

// Optimize to O(1):
let prev2 = cost[0];
let prev1 = Math.min(cost[0] + cost[1], cost[1]);
```

✅ **Correct space-optimized solution:**
```javascript
function minCostClimbingStairs(cost) {
  if (cost.length === 2) return Math.min(cost[0], cost[1]);

  let prev2 = cost[0];
  let prev1 = Math.min(cost[0] + cost[1], cost[1]);

  for (let i = 2; i < cost.length; i++) {
    const current = cost[i] + Math.min(prev2, prev1);
    prev2 = prev1;
    prev1 = current;
  }

  return Math.min(prev1, prev2);
}
```

## Interview Tips

**When discussing:**
1. Clarify: "The top is one step beyond the last element"
2. Start options: "Can start at step 0 or step 1"
3. Recurrence: "Min cost to step i = cost[i] + min of two previous steps"
4. Key detail: "Return min of cost to reach last or second-to-last step"
5. Optimize: "Only need last two values for O(1) space"

**Key talking points:**
- "Similar to climbing stairs but minimize cost instead of counting ways"
- "The 'top' is conceptually one step beyond the array"
- "From any position, can reach top by climbing 1 or 2 steps"
- "At each step, choose the cheaper path from the two previous steps"

**Follow-up questions:**

**Q: What if you can only climb 1 step at a time?**
A: Sum all costs: `return cost.reduce((a, b) => a + b, 0)`

**Q: What if you can climb k steps?**
A: Recurrence becomes: `dp[i] = cost[i] + min(dp[i-1], dp[i-2], ..., dp[i-k])`

**Q: Return the path taken?**
A: Backtrack from the end, choosing which previous step we came from.

**Q: What if some steps are blocked?**
A: Skip those steps in DP calculation, or set their cost to infinity.

## Edge Cases

```javascript
minCostClimbingStairs([1, 2]) → 1
  // Start at 0, cost 1, then jump 2 steps to top

minCostClimbingStairs([10, 10]) → 10
  // Start at either 0 or 1, cost 10, jump to top

minCostClimbingStairs([1, 100, 1, 1, 1]) → 3
  // Avoid expensive step 1

minCostClimbingStairs([1, 1, 1, 1]) → 2
  // Skip every other step
```

## Related Problems

- **Climbing Stairs** (Easy) - Count ways instead of minimizing cost
- **House Robber** (Easy) - Similar constraint but linear (circle in HR II)
- **Jump Game** (Medium) - Can you reach the end?
- **Jump Game II** (Medium) - Minimum jumps to reach end
