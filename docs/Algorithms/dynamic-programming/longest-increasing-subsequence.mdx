---
sidebar_position: 7
difficulty: Medium
tags: [dynamic-programming, binary-search, array]
leetcode_url: https://leetcode.com/problems/longest-increasing-subsequence/
companies: [Amazon, Microsoft, Meta, Google, Apple]
pattern: "Dynamic Programming"
---

import AlgorithmProblem from '@site/src/components/AlgorithmProblem';

# Longest Increasing Subsequence

<AlgorithmProblem
  title="Longest Increasing Subsequence"
  difficulty="Medium"
  description={`
<p>Given an integer array <code>nums</code>, return the <em>length of the <strong>longest strictly increasing subsequence</strong></em>.</p>
<p>A <strong>subsequence</strong> is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements.</p>
<h4>Constraints:</h4>
<ul>
  <li>1 &le; nums.length &le; 2500</li>
  <li>-10<sup>4</sup> &le; nums[i] &le; 10<sup>4</sup></li>
</ul>
<h4>Follow up:</h4>
<p>Can you come up with an algorithm that runs in <code>O(n log n)</code> time complexity?</p>
`}
  examples={[
    {
      input: 'nums = [10,9,2,5,3,7,101,18]',
      output: '4',
      explanation: 'The longest increasing subsequence is [2,3,7,101], with length 4'
    },
    {
      input: 'nums = [0,1,0,4,4,4,3,5,3]',
      output: '4',
      explanation: 'The longest is [0,1,4,5] with length 4'
    },
    {
      input: 'nums = [3,2,1]',
      output: '1',
      explanation: 'No pair of numbers can form increasing subsequence'
    }
  ]}
  starterCode={`function lengthOfLIS(nums) {
  // Write your code here

}`}
  solution={`function lengthOfLIS(nums) {
  // O(n log n) - Binary Search with DP: O(n log n) time, O(n) space
  // dp[i] = smallest tail of increasing subsequence of length i+1
  const dp = [];

  for (const num of nums) {
    // Find position where num should be inserted
    let left = 0, right = dp.length;

    while (left < right) {
      const mid = Math.floor((left + right) / 2);
      if (dp[mid] < num) {
        left = mid + 1;
      } else {
        right = mid;
      }
    }

    // Either replace or append
    if (left === dp.length) {
      dp.push(num);
    } else {
      dp[left] = num;
    }
  }

  return dp.length;
}`}
  testCases={[
    {
      input: [[10, 9, 2, 5, 3, 7, 101, 18]],
      expected: 4,
      description: 'Longest is [2,3,7,101]'
    },
    {
      input: [[0, 1, 0, 4, 4, 4, 3, 5, 3]],
      expected: 4,
      description: 'Longest is [0,1,4,5]'
    },
    {
      input: [[3, 2, 1]],
      expected: 1,
      description: 'All descending'
    },
    {
      input: [[1]],
      expected: 1,
      description: 'Single element'
    },
    {
      input: [[1, 2, 3, 4, 5]],
      expected: 5,
      description: 'Fully ascending'
    },
    {
      input: [[5, 4, 3, 2, 1]],
      expected: 1,
      description: 'Fully descending'
    }
  ]}
  functionName="lengthOfLIS"
/>

## Solution Explanation

### Approach 1: Brute Force - 2D DP

**Time Complexity:** O(n²)
**Space Complexity:** O(n)

For each element, check all previous elements:

```javascript
function lengthOfLIS(nums) {
  // dp[i] = length of LIS ending at index i
  const dp = new Array(nums.length).fill(1);

  for (let i = 1; i < nums.length; i++) {
    for (let j = 0; j < i; j++) {
      if (nums[j] < nums[i]) {
        // Can extend LIS ending at j with nums[i]
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
  }

  return Math.max(...dp);
}

// Trace: nums = [10, 9, 2, 5, 3, 7, 101, 18]
// i=0: dp[0] = 1
// i=1: nums[0]=10 >= nums[1]=9, no update, dp[1] = 1
// i=2: nums[0]=10 >= nums[2]=2, nums[1]=9 >= nums[2]=2, dp[2] = 1
// i=3: nums[0]=10 >= nums[3]=5, nums[1]=9 >= nums[3]=5,
//      nums[2]=2 < nums[3]=5, dp[3] = max(1, dp[2]+1) = 2
// i=4: nums[2]=2 < nums[4]=3, dp[4] = max(1, dp[2]+1) = 2
// i=5: nums[2]=2 < nums[5]=7, nums[3]=5 < nums[5]=7, nums[4]=3 < nums[5]=7,
//      dp[5] = max(1, dp[4]+1) = 3
// i=6: All previous nums < 101, dp[6] = max(1, 3+1) = 4
// i=7: 10 < 18, 9 < 18, 2 < 18, 5 < 18, 3 < 18, 7 < 18,
//      dp[7] = max(1, 3+1) = 4
// max(dp) = 4
```

**How it works:**
- `dp[i]` = length of longest increasing subsequence ending at index i
- For each i, look back at all j < i
- If nums[j] < nums[i], we can extend the LIS from j
- Take maximum extension

### Approach 2: Binary Search + DP (Optimal) ✅

**Time Complexity:** O(n log n)
**Space Complexity:** O(n)

Maintain array of smallest tails for each LIS length:

```javascript
function lengthOfLIS(nums) {
  // dp[i] = smallest tail of increasing subsequence of length i+1
  const dp = [];

  for (const num of nums) {
    // Binary search for position to insert/replace
    let left = 0, right = dp.length;

    while (left < right) {
      const mid = Math.floor((left + right) / 2);
      if (dp[mid] < num) {
        left = mid + 1;
      } else {
        right = mid;
      }
    }

    // Either append (extend LIS) or replace (improve tail)
    if (left === dp.length) {
      dp.push(num);
    } else {
      dp[left] = num;
    }
  }

  return dp.length;
}

// Trace: nums = [10, 9, 2, 5, 3, 7, 101, 18]
// num=10: dp=[], insert at 0, dp=[10]
// num=9:  dp=[10], 9 < 10, replace dp[0], dp=[9]
// num=2:  dp=[9], 2 < 9, replace dp[0], dp=[2]
// num=5:  dp=[2], 5 > 2, append, dp=[2,5]
// num=3:  dp=[2,5], 3 > 2 but 3 < 5, replace dp[1], dp=[2,3]
// num=7:  dp=[2,3], 7 > 3, append, dp=[2,3,7]
// num=101:dp=[2,3,7], 101 > 7, append, dp=[2,3,7,101]
// num=18: dp=[2,3,7,101], 18 > 7 but 18 < 101, replace dp[3], dp=[2,3,7,18]
// return 4 ✓
```

**Key insight:** Maintain the smallest possible tail for each subsequence length. When a new number comes:
- If larger than all tails: extend longest subsequence
- If fits in middle: replace tail to potentially improve future extensions

## Understanding the Binary Search DP

**Why does replacing a tail work?**

Consider: [2, 3, 7, 101] vs [2, 3, 7, 18]

Both have length 4. The second one is "better" because 18 < 101 (smaller tail). If future element 50 comes:
- Can't extend [2, 3, 7, 101]
- Can extend [2, 3, 7, 18] to [2, 3, 7, 18, 50]

**The dp array invariant:**
- `dp[i]` is the smallest tail of any increasing subsequence of length i+1
- This is always maintained correctly by our replacement strategy

## Comparison of Approaches

| Approach | Time | Space | Pros | Cons |
|----------|------|-------|------|------|
| Brute Force 2D DP | O(n²) | O(n) | Intuitive | Slow |
| **Binary Search** | **O(n log n)** | **O(n)** | **Optimal** | **Complex** |

## Visualization: Binary Search Approach

```
nums = [10, 9, 2, 5, 3, 7, 101, 18]

num=10: dp=[10]           Length 1: tail 10
num=9:  dp=[9]            Length 1: tail 9 (better)
num=2:  dp=[2]            Length 1: tail 2 (better)
num=5:  dp=[2, 5]         Length 2: tails [2, 5]
num=3:  dp=[2, 3]         Length 2: tails [2, 3] (improved)
num=7:  dp=[2, 3, 7]      Length 3: tails [2, 3, 7]
num=101:dp=[2, 3, 7, 101] Length 4: tails [2, 3, 7, 101]
num=18: dp=[2, 3, 7, 18]  Length 4: tails [2, 3, 7, 18] (improved)

Answer: 4 (length of longest increasing subsequence)
```

## Common Mistakes

❌ **Using incorrect binary search logic:**
```javascript
// Wrong - might not find correct insertion point
const index = dp.findIndex(x => x >= num);

// Correct - use proper binary search
let left = 0, right = dp.length;
while (left < right) {
  const mid = Math.floor((left + right) / 2);
  if (dp[mid] < num) {
    left = mid + 1;
  } else {
    right = mid;
  }
}
```

❌ **Not understanding the replace strategy:**
```javascript
// Wrong - always append, doesn't improve dp array
dp.push(num);

// Correct - replace or append based on position
if (left === dp.length) {
  dp.push(num);
} else {
  dp[left] = num;
}
```

❌ **Using 2D DP when time matters:**
```javascript
// O(n²) - slow for large n
const dp = new Array(nums.length).fill(1);
for (let i = 1; i < nums.length; i++) {
  for (let j = 0; j < i; j++) {
    if (nums[j] < nums[i]) {
      dp[i] = Math.max(dp[i], dp[j] + 1);
    }
  }
}
return Math.max(...dp);

// O(n log n) - much better!
const dp = [];
for (const num of nums) {
  // Binary search and update dp
}
```

✅ **Correct binary search solution:**
```javascript
function lengthOfLIS(nums) {
  const dp = [];

  for (const num of nums) {
    let left = 0, right = dp.length;

    while (left < right) {
      const mid = Math.floor((left + right) / 2);
      if (dp[mid] < num) {
        left = mid + 1;
      } else {
        right = mid;
      }
    }

    if (left === dp.length) {
      dp.push(num);
    } else {
      dp[left] = num;
    }
  }

  return dp.length;
}
```

## Interview Tips

**When discussing:**
1. State: "`dp[i]` = length of LIS ending at index i" (O(n²) approach)
2. Optimize: "Maintain smallest tail for each length" (O(n log n))
3. Key: "Replace worse tail with better one"
4. Binary search: "Find position efficiently with log n"
5. Complexity: "O(n log n) time, O(n) space"

**Key talking points:**
- "This is a classic DP problem with two approaches"
- "Naive approach is O(n²), but binary search optimizes to O(n log n)"
- "The trick is maintaining the best possible tail for each length"
- "When a number comes, it either extends or improves a subsequence"
- "Binary search finds the right position in log n time"

**Follow-up questions:**

**Q: Return the actual subsequence, not just length?**
A: Maintain parent pointers or reconstruct from dp array.

**Q: What if subsequence must be non-strictly increasing (<=)?**
A: Use `<=` instead of `<` in comparisons.

**Q: Can you solve this without binary search?**
A: Yes, O(n²) DP is easier to implement but slower.

**Q: What if you need all longest increasing subsequences?**
A: Backtracking after computing lengths, more complex.

## Edge Cases

```javascript
lengthOfLIS([1]) → 1                      // Single element
lengthOfLIS([1, 1, 1]) → 1               // All same
lengthOfLIS([1, 2, 3, 4, 5]) → 5         // Fully ascending
lengthOfLIS([5, 4, 3, 2, 1]) → 1         // Fully descending
lengthOfLIS([10, 9, 2, 5, 3, 7]) → 3    // Mixed
lengthOfLIS([-1, -2, -3, -4]) → 1        // Negative descending
```

## Related Problems

- **Longest Decreasing Subsequence** - Reverse the logic
- **Longest Bitonic Subsequence** - Increase then decrease
- **Maximum Length of Pair Chain** (Medium) - Similar DP pattern
- **Number of Longest Increasing Subsequence** (Hard) - Count all
- **Longest Continuous Increasing Subsequence** (Easy) - Contiguous only
