---
sidebar_position: 6
difficulty: Medium
tags: [dynamic-programming, array, bfs, greedy]
leetcode_url: https://leetcode.com/problems/coin-change/
companies: [Google, Amazon, Meta, Apple, Microsoft]
pattern: "Dynamic Programming"
---

import AlgorithmProblem from '@site/src/components/AlgorithmProblem';

# Coin Change

<AlgorithmProblem
  title="Coin Change"
  difficulty="Medium"
  description={`
<p>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p>
<p>Return <em>the <strong>fewest number of coins</strong> that you need to make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>
<p>You may assume that you have an infinite number of each kind of coin.</p>
<h4>Constraints:</h4>
<ul>
  <li>1 &le; coins.length &le; 12</li>
  <li>1 &le; coins[i] &le; 2<sup>31</sup> - 1</li>
  <li>0 &le; amount &le; 10<sup>4</sup></li>
</ul>
`}
  examples={[
    {
      input: 'coins = [1,2,5], amount = 5',
      output: '1',
      explanation: 'Use a single coin of denomination 5'
    },
    {
      input: 'coins = [2], amount = 3',
      output: '-1',
      explanation: 'Cannot make amount 3 with only 2 coins'
    },
    {
      input: 'coins = [10], amount = 10',
      output: '1',
      explanation: 'Single coin of denomination 10'
    }
  ]}
  starterCode={`function coinChange(coins, amount) {
  // Write your code here

}`}
  solution={`function coinChange(coins, amount) {
  // DP - Tabulation: O(n * amount) time, O(amount) space
  // dp[i] = minimum coins needed to make amount i
  const dp = new Array(amount + 1).fill(Infinity);
  dp[0] = 0; // Base case: 0 coins needed for amount 0

  for (let i = 1; i <= amount; i++) {
    // Try using each coin
    for (const coin of coins) {
      if (coin <= i) {
        // If we use this coin, need 1 + dp[i - coin] coins
        dp[i] = Math.min(dp[i], dp[i - coin] + 1);
      }
    }
  }

  return dp[amount] === Infinity ? -1 : dp[amount];
}`}
  testCases={[
    {
      input: [[1, 2, 5], 5],
      expected: 1,
      description: 'Use single coin of 5'
    },
    {
      input: [[2], 3],
      expected: -1,
      description: 'Impossible with only 2 coin'
    },
    {
      input: [[10], 10],
      expected: 1,
      description: 'Single coin of 10'
    },
    {
      input: [[1, 2, 5], 7],
      expected: 2,
      description: 'Use 5 + 2'
    },
    {
      input: [[3, 4], 6],
      expected: 2,
      description: 'Use 3 + 3'
    },
    {
      input: [[2, 5, 10], 27],
      expected: 4,
      description: 'Use 10 + 10 + 5 + 2'
    }
  ]}
  functionName="coinChange"
/>

## Solution Explanation

### Approach 1: Brute Force Recursion

**Time Complexity:** O(m<sup>n</sup>) exponential
**Space Complexity:** O(n) recursive stack

Try all combinations:

```javascript
function coinChange(coins, amount) {
  function helper(remaining) {
    // Base cases
    if (remaining === 0) return 0;  // No coins needed
    if (remaining < 0) return -1;   // Invalid state

    let minCoins = Infinity;

    // Try each coin
    for (const coin of coins) {
      const result = helper(remaining - coin);

      if (result !== -1) {
        minCoins = Math.min(minCoins, result + 1);
      }
    }

    return minCoins === Infinity ? -1 : minCoins;
  }

  return helper(amount);
}

// Trace: coins = [1, 2, 5], amount = 5
//                  helper(5)
//        /          |           \
//   helper(4)   helper(3)    helper(0) = 0
//    /  | \      /  | \       (return 1)
//  h(3) h(2) h(-1) ...
//  (lots of recursive calls, many duplicated)
```

**Why avoid?** Exponential overlapping subproblems.

### Approach 2: Memoization (Top-down)

**Time Complexity:** O(n &#215; amount)
**Space Complexity:** O(amount)

Cache results:

```javascript
function coinChange(coins, amount) {
  const memo = {};

  function helper(remaining) {
    if (remaining === 0) return 0;
    if (remaining < 0) return -1;

    if (remaining in memo) return memo[remaining];

    let minCoins = Infinity;

    for (const coin of coins) {
      const result = helper(remaining - coin);
      if (result !== -1) {
        minCoins = Math.min(minCoins, result + 1);
      }
    }

    memo[remaining] = minCoins === Infinity ? -1 : minCoins;
    return memo[remaining];
  }

  return helper(amount);
}

// With memoization:
// helper(5) computed once and cached
// helper(4) computed once and cached
// helper(3) computed once and cached
// ...
// Total: O(amount) unique states × O(n) coins = O(n × amount)
```

### Approach 3: DP Tabulation (Optimal) ✅

**Time Complexity:** O(n &#215; amount)
**Space Complexity:** O(amount)

Build table bottom-up:

```javascript
function coinChange(coins, amount) {
  // dp[i] = minimum coins to make amount i
  const dp = new Array(amount + 1).fill(Infinity);
  dp[0] = 0; // Base case: 0 coins for amount 0

  for (let i = 1; i <= amount; i++) {
    // Try using each coin
    for (const coin of coins) {
      if (coin <= i) {
        // If we use coin, need 1 + coins for (i - coin)
        dp[i] = Math.min(dp[i], dp[i - coin] + 1);
      }
    }
  }

  return dp[amount] === Infinity ? -1 : dp[amount];
}

// Trace: coins = [1, 2, 5], amount = 5
// dp[0] = 0
// dp[1]: coin=1: dp[1] = min(Inf, dp[0] + 1) = 1
// dp[2]: coin=1: dp[2] = min(Inf, dp[1] + 1) = 2
//        coin=2: dp[2] = min(2, dp[0] + 1) = 1
// dp[3]: coin=1: dp[3] = min(Inf, dp[2] + 1) = 2
//        coin=2: dp[3] = min(2, dp[1] + 1) = 2
// dp[4]: coin=1: dp[4] = min(Inf, dp[3] + 1) = 3
//        coin=2: dp[4] = min(3, dp[2] + 1) = 2
// dp[5]: coin=1: dp[5] = min(Inf, dp[4] + 1) = 3
//        coin=2: dp[5] = min(3, dp[3] + 1) = 3
//        coin=5: dp[5] = min(3, dp[0] + 1) = 1 ✓
// dp = [0, 1, 1, 2, 2, 1]
// return 1
```

## DP Recurrence Relation

```
dp[i] = minimum coins needed to make amount i

For each amount i from 1 to target:
  For each coin in coins:
    if coin <= i:
      dp[i] = min(dp[i], dp[i - coin] + 1)

Where:
- dp[i - coin] = coins needed for remaining amount
- + 1 = the coin we're using now

Base case:
- dp[0] = 0 (no coins needed for amount 0)

Answer:
- dp[amount] (if reachable, otherwise -1)
```

## Key Insights

**Why this DP works:**

For amount i, we ask: "Can I reach i by using one of the coins?"

```
For each coin c in coins:
  if c <= i:
    ways_to_make_i_using_c = 1 + ways_to_make_(i-c)

Choose the way that uses minimum coins
```

**Initialization:**
- Use `Infinity` to represent impossible states
- Only `dp[0] = 0` is possible initially
- As we compute, more states become reachable

**Transition order:**
- Go from amount 0 to target amount
- Ensures `dp[i - coin]` is already computed before we use it

## Visualization

```
coins = [1, 2, 5], amount = 5

Building the dp table:
Amount: 0  1  2  3  4  5
dp:     0  1  1  2  2  1
         ↑  ↑  ↑  ↑  ↑  ↑
         |  |  |  |  |  └─ 1×5
         |  |  |  |  └───── 2×2
         |  |  |  └──────── 1×2 + 1×1
         |  |  └─────────── 1×2
         |  └────────────── 1×1
         └───────────────── base case

Paths:
- Amount 0: no coins
- Amount 1: 1 coin (1)
- Amount 2: 1 coin (2)
- Amount 3: 2 coins (2+1)
- Amount 4: 2 coins (2+2)
- Amount 5: 1 coin (5) ← answer
```

## Comparison of Approaches

| Approach | Time | Space | Pros | Cons |
|----------|------|-------|------|------|
| Brute Force | O(m<sup>n</sup>) | O(n) | Simple | Exponential |
| Memoization | O(n × amount) | O(amount) | Intuitive | Top-down |
| **Tabulation** | **O(n × amount)** | **O(amount)** | **Standard DP** | **Optimal** |

## Common Mistakes

❌ **Initializing dp[i] = 0 for all i:**
```javascript
// Wrong - all amounts would seem possible
const dp = new Array(amount + 1).fill(0);

// Correct - use Infinity for impossible states
const dp = new Array(amount + 1).fill(Infinity);
```

❌ **Forgetting to check if coin <= i:**
```javascript
// Wrong - negative indices!
for (const coin of coins) {
  dp[i] = Math.min(dp[i], dp[i - coin] + 1);  // crash if i < coin!
}

// Correct - guard condition
for (const coin of coins) {
  if (coin <= i) {
    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
  }
}
```

❌ **Not returning -1 when amount is unreachable:**
```javascript
// Wrong - returns Infinity
return dp[amount];

// Correct - check and return -1 if impossible
return dp[amount] === Infinity ? -1 : dp[amount];
```

❌ **Iterating coins in outer loop:**
```javascript
// Wrong order - leads to counting different orderings
for (const coin of coins) {
  for (let i = coin; i <= amount; i++) {
    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
  }
}
// This treats [2,1] and [1,2] as different, wrong for this problem!

// Correct - amount in outer loop
for (let i = 1; i <= amount; i++) {
  for (const coin of coins) {
    if (coin <= i) {
      dp[i] = Math.min(dp[i], dp[i - coin] + 1);
    }
  }
}
```

✅ **Correct solution:**
```javascript
function coinChange(coins, amount) {
  const dp = new Array(amount + 1).fill(Infinity);
  dp[0] = 0;

  for (let i = 1; i <= amount; i++) {
    for (const coin of coins) {
      if (coin <= i && dp[i - coin] !== Infinity) {
        dp[i] = Math.min(dp[i], dp[i - coin] + 1);
      }
    }
  }

  return dp[amount] === Infinity ? -1 : dp[amount];
}
```

## Interview Tips

**When discussing:**
1. Identify: "This is an unbounded knapsack DP problem"
2. State: "`dp[i]` = minimum coins to make amount i"
3. Transition: "Try each coin, pick minimum result"
4. Base: "`dp[0] = 0`, other states impossible initially"
5. Iterate: "Build from amount 0 to target amount"
6. Return: "Check if amount is reachable (-1 if not)"

**Key talking points:**
- "Similar to coin change II, but we minimize coins instead of counting ways"
- "Use Infinity to mark impossible states"
- "Must check `coin <= i` to avoid negative indices"
- "Iterate amounts in outer loop, coins in inner loop"
- "Time is O(amount × coins), space is O(amount)"

**Follow-up questions:**

**Q: What if you have limited coins of each type?**
A: Different problem (0/1 knapsack). Track which coins are used.

**Q: Return the actual coins, not just count?**
A: Backtrack from `dp[amount]`, tracking which coin was used.

**Q: What if coins list is very long?**
A: Still O(amount × n), so coin count matters more than amount.

**Q: What about optimizing space?**
A: Can use 1D array in-place, but can't optimize further than O(amount).

## Edge Cases

```javascript
coinChange([1, 2, 5], 0) → 0        // Amount 0
coinChange([2], 3) → -1             // Impossible
coinChange([5], 5) → 1              // Exact match
coinChange([1], 100) → 100          // All ones
coinChange([3, 4], 6) → 2           // Multiple coins
coinChange([3, 4], 1) → -1          // Impossible with large coins
```

## Related Problems

- **Coin Change II** (Medium) - Count number of ways
- **Coin Change Combination** (Medium) - Combinations vs permutations
- **Perfect Squares** (Medium) - Similar: min perfect squares summing to n
- **Target Sum** (Medium) - Achieve target with +/-operations
- **Knapsack Problems** (Medium-Hard) - Generalized version
